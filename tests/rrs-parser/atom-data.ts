import { FeedPost } from "../../src/feeds/feed";

export const firstAtomEntry: FeedPost = {
  title: "Fourteen Years of Go",
  link: "https://go.dev/blog/14years",
  summary: "Happy Birthday, Go!",
  publish: new Date(Date.UTC(2023, 10, 10, 0, 0, 0)),
};

export const atomData =
  '<feed xmlns="http://www.w3.org/2005/Atom"><title>The Go Blog</title><id>tag:blog.golang.org,2013:blog.golang.org</id><link rel="self" href="https://go.dev/blog/feed.atom"></link><updated>2023-11-10T00:00:00+00:00</updated><entry><title>Fourteen Years of Go</title><id>tag:blog.golang.org,2013:blog.golang.org/14years</id><link rel="alternate" href="https://go.dev/blog/14years"></link><published>2023-11-10T00:00:00+00:00</published><updated>2023-11-10T00:00:00+00:00</updated><author><name></name></author><summary type="html">Happy Birthday, Go!</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/14years&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Fourteen Years of Go&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Russ Cox, for the Go team&lt;br&gt;&#xA;      10 November 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;img src=&#34;/doc/gopher/gopherdrink.png&#34; height=&#34;219&#34; width=&#34;223&#34; align=&#34;right&#34; style=&#34;margin: 0 0 1em 1em;&#34;&gt;&#xA;&lt;p&gt;Today we celebrate the fourteenth birthday of the Go open source release!&#xA;Go has had a great year, with two feature-filled releases and other important milestones.&lt;/p&gt;&#xA;&lt;p&gt;We released &lt;a href=&#34;/blog/go1.20&#34;&gt;Go 1.20 in February&lt;/a&gt;&#xA;and &lt;a href=&#34;/blog/go1.21&#34;&gt;Go 1.21 in August&lt;/a&gt;,&#xA;focusing more on implementation improvements&#xA;than new language changes.&lt;/p&gt;&#xA;&lt;p&gt;Profile-guided optimization (PGO),&#xA;&lt;a href=&#34;/blog/pgo-preview&#34;&gt;previewed in Go 1.20&lt;/a&gt;&#xA;and&#xA;&lt;a href=&#34;/blog/pgo&#34;&gt;released in Go 1.21&lt;/a&gt;,&#xA;allows the Go compiler to read a profile of your program&#xA;and then spend more time optimizing the parts&#xA;of your program that run most often.&#xA;In Go 1.21, workloads typically get between&#xA;2% and 7% CPU usage improvements from enabling PGO.&#xA;See “&lt;a href=&#34;/blog/pgo&#34;&gt;Profile-guided optimization in Go 1.21&lt;/a&gt;” for an overview&#xA;and the &lt;a href=&#34;https://go.dev/doc/pgo&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;profile-guided optimization user guide&lt;/a&gt;&#xA;for complete documentation.&lt;/p&gt;&#xA;&lt;p&gt;Go has provided support for gathering coverage profiles during &lt;code&gt;go test&lt;/code&gt;&#xA;&lt;a href=&#34;/blog/cover&#34;&gt;since Go 1.2&lt;/a&gt;.&#xA;Go 1.20 added support for gathering coverage profiles in binaries&#xA;built by &lt;code&gt;go build&lt;/code&gt;,&#xA;allowing you to gather coverage during larger integration tests as well.&#xA;See “&lt;a href=&#34;/blog/integration-test-coverage&#34;&gt;Code coverage for Go integration tests&lt;/a&gt;” for details.&lt;/p&gt;&#xA;&lt;p&gt;Compatibility has been an important part of Go since&#xA;“&lt;a href=&#34;/doc/go1compat&#34;&gt;Go 1 and the Future of Go Programs&lt;/a&gt;”.&#xA;Go 1.21 improved compatibility further&#xA;by expanding the conventions for use of GODEBUG&#xA;in situations where we need to make a change,&#xA;such as an important bug fix,&#xA;that must be permitted but may still break existing programs.&#xA;See the blog post&#xA;“&lt;a href=&#34;/blog/compat&#34;&gt;Backward Compatibility, Go 1.21, and Go 2&lt;/a&gt;”&#xA;for an overview and&#xA;the documentation&#xA;“&lt;a href=&#34;/doc/godebug&#34;&gt;Go, Backwards Compatibility, and GODEBUG&lt;/a&gt;” for details.&lt;/p&gt;&#xA;&lt;p&gt;Go 1.21 also shipped support for built-in toolchain management,&#xA;allowing you to change which version of the&#xA;Go toolchain you use in a specific module&#xA;as easily as you change the versions of other dependencies.&#xA;See the blog post&#xA;“&lt;a href=&#34;/blog/toolchain&#34;&gt;Forward Compatibility and Toolchain Management in Go 1.21&lt;/a&gt;”&#xA;for an overview and the documentation&#xA;“&lt;a href=&#34;/doc/toolchain&#34;&gt;Go Toolchains&lt;/a&gt;”&#xA;for details.&lt;/p&gt;&#xA;&lt;p&gt;Another important tooling achievement was the&#xA;integration of on-disk indexes into&#xA;gopls, the Go LSP server.&#xA;This cut gopls&amp;rsquo;s startup latency and memory usage by 3-5X&#xA;in typical use cases.&#xA;“&lt;a href=&#34;/blog/gopls-scalability&#34;&gt;Scaling gopls for the growing Go ecosystem&lt;/a&gt;”&#xA;explains the technical details.&#xA;You can make sure you&amp;rsquo;re running the latest gopls by running:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go install golang.org/x/tools/gopls@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Go 1.21 introduced new&#xA;&lt;a href=&#34;/pkg/cmp/&#34;&gt;cmp&lt;/a&gt;,&#xA;&lt;a href=&#34;/pkg/maps/&#34;&gt;maps&lt;/a&gt;,&#xA;and&#xA;&lt;a href=&#34;/pkg/slices/&#34;&gt;slices&lt;/a&gt;&#xA;packages — Go’s first generic standard libraries —&#xA;as well as expanding the set of comparable types.&#xA;For details about that, see the blog post&#xA;“&lt;a href=&#34;/blog/comparable&#34;&gt;All your comparable types&lt;/a&gt;”.&lt;/p&gt;&#xA;&lt;p&gt;Overall, we continue to refine generics&#xA;and to write talks and blog posts explaining&#xA;important details.&#xA;Two notable posts this year were&#xA;“&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;”,&#xA;and&#xA;“&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference – And a Little Bit More&lt;/a&gt;”.&lt;/p&gt;&#xA;&lt;p&gt;Another important new package in Go 1.21 is&#xA;&lt;a href=&#34;/pkg/log/slog/&#34;&gt;log/slog&lt;/a&gt;,&#xA;which adds an official API for&#xA;structured logging to the standard library.&#xA;See “&lt;a href=&#34;/blog/slog&#34;&gt;Structured logging with slog&lt;/a&gt;” for an overview.&lt;/p&gt;&#xA;&lt;p&gt;For the WebAssembly (Wasm) port, Go 1.21 shipped support&#xA;for running on WebAssembly System Interface (WASI) preview 1.&#xA;WASI preview 1 is a new “operating system” interface for Wasm&#xA;that is supported by most server-side Wasm environments.&#xA;See “&lt;a href=&#34;/blog/wasi&#34;&gt;WASI support in Go&lt;/a&gt;” for a walkthrough.&lt;/p&gt;&#xA;&lt;p&gt;On the security side, we are continuing to make sure&#xA;Go leads the way in helping developers understand their&#xA;dependencies and vulnerabilities,&#xA;with &lt;a href=&#34;/blog/govulncheck&#34;&gt;Govulncheck 1.0 launching in July&lt;/a&gt;.&#xA;If you use VS Code, you can run govulncheck directly in your&#xA;editor using the Go extension:&#xA;see &lt;a href=&#34;https://go.dev/doc/tutorial/govulncheck-ide&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;this tutorial&lt;/a&gt; to get started.&#xA;And if you use GitHub, you can run govulncheck as part of&#xA;your CI/CD, with the&#xA;&lt;a href=&#34;https://github.com/marketplace/actions/golang-govulncheck-action&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub Action for govulncheck&lt;/a&gt;.&#xA;For more about checking your dependencies for vulnerability problems,&#xA;see this year&amp;rsquo;s Google I/O talk,&#xA;“&lt;a href=&#34;https://www.youtube.com/watch?v=HSt6FhsPT8c&amp;amp;ab_channel=TheGoProgrammingLanguage&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Build more secure apps with Go and Google&lt;/a&gt;”.)&lt;/p&gt;&#xA;&lt;p&gt;Another important security milestone was&#xA;Go 1.21&amp;rsquo;s highly reproducible toolchain builds.&#xA;See “&lt;a href=&#34;/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;” for details,&#xA;including a demonstration of reproducing an Ubuntu Linux Go toolchain&#xA;on a Mac without using any Linux tools at all.&lt;/p&gt;&#xA;&lt;p&gt;It has been a busy year!&lt;/p&gt;&#xA;&lt;p&gt;In Go&amp;rsquo;s 15th year, we&amp;rsquo;ll keep working to make Go the best environment&#xA;for software engineering at scale.&#xA;One change we&amp;rsquo;re particularly excited about is&#xA;redefining for loop &lt;code&gt;:=&lt;/code&gt; semantics to remove the&#xA;potential for accidental aliasing bugs.&#xA;See “&lt;a href=&#34;/blog/loopvar-preview&#34;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;”&#xA;for details,&#xA;including instructions for previewing this change in Go 1.21.&lt;/p&gt;&#xA;&lt;h2 id=&#34;thank-you&#34;&gt;Thank You!&lt;/h2&gt;&#xA;&lt;p&gt;The Go project has always been far more than just us on the Go team at Google.&#xA;Thank you to all our contributors and everyone in the Go community for&#xA;making Go what it is today.&#xA;We wish you all the best in the year ahead.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Everything You Always Wanted to Know About Type Inference - And a Little Bit More</title><id>tag:blog.golang.org,2013:blog.golang.org/type-inference</id><link rel="alternate" href="https://go.dev/blog/type-inference"></link><published>2023-10-09T00:00:00+00:00</published><updated>2023-10-09T00:00:00+00:00</updated><author><name></name></author><summary type="html">A description of how type inference for Go works. Based on the GopherCon 2023 talk with the same title.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/type-inference&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Robert Griesemer&lt;br&gt;&#xA;      9 October 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;This is the blog version of my talk on type inference at GopherCon 2023 in San Diego,&#xA;slightly expanded and edited for clarity.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-type-inference&#34;&gt;What is type inference?&lt;/h2&gt;&#xA;&lt;p&gt;Wikipedia defines type inference as follows:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Type inference is the ability to automatically deduce, either partially or fully,&#xA;the type of an expression at compile time.&#xA;The compiler is often able to infer the type of a variable or the type signature of&#xA;a function, without explicit type annotations having been given.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;The key phrase here is &amp;ldquo;automatically deduce &amp;hellip; the type of an expression&amp;rdquo;.&#xA;Go supported a basic form of type inference from the start:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;const x = expr  // the type of x is the type of expr&#xA;var x = expr&#xA;x := expr&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;No explicit types are given in these declarations,&#xA;and therefore the types of the constant and variables &lt;code&gt;x&lt;/code&gt; on the left of &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;:=&lt;/code&gt;&#xA;are the types of the respective initialization expressions, on the right.&#xA;We say that the types are &lt;em&gt;inferred&lt;/em&gt; from (the types of) their initialization expressions.&#xA;With the introduction of generics in Go 1.18, Go&amp;rsquo;s type inference abilities&#xA;were significantly expanded.&lt;/p&gt;&#xA;&lt;h3 id=&#34;why-type-inference&#34;&gt;Why type inference?&lt;/h3&gt;&#xA;&lt;p&gt;In non-generic Go code, the effect of leaving away types is most pronounced in a short variable declaration.&#xA;Such a declaration combines type inference and a little bit of syntactic&#xA;sugar—the ability to leave away the &lt;code&gt;var&lt;/code&gt; keyword—into one very compact statement.&#xA;Consider the following map variable declaration:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;var m map[string]int = map[string]int{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;vs&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;m := map[string]int{}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Omitting the type on the left of &lt;code&gt;:=&lt;/code&gt; removes repetition and at the same time increases readability.&lt;/p&gt;&#xA;&lt;p&gt;Generic Go code has the potential to significantly increase the number of types appearing in code:&#xA;without type inference, each generic function and type instantiation requires type arguments.&#xA;Being able to omit them becomes even more important.&#xA;Consider using the following two functions from the new&#xA;&lt;a href=&#34;https://pkg.go.dev/slices&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;slices package&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;package slices&#xA;func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)&#xA;func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Without type inference, calling &lt;code&gt;BinarySearch&lt;/code&gt; and &lt;code&gt;Sort&lt;/code&gt; requires explicit type arguments:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type List []int&#xA;var list List&#xA;slices.Sort[List, int](list)&#xA;index, found := slices.BinarySearch[List, int](list, 42)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We&amp;rsquo;d rather not repeat &lt;code&gt;[List, int]&lt;/code&gt; with each such generic function call.&#xA;With type inference the code simplifies to:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;index, found := slices.BinarySearch(list, 42)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is both cleaner and more compact.&#xA;In fact it looks exactly like non-generic code,&#xA;and type inference makes this possible.&lt;/p&gt;&#xA;&lt;p&gt;Importantly, type inference is an optional mechanism:&#xA;if type arguments make code clearer, by all means, write them down.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-inference-is-a-form-of-type-pattern-matching&#34;&gt;Type inference is a form of type pattern matching&lt;/h2&gt;&#xA;&lt;p&gt;Inference compares type patterns,&#xA;where a type pattern is a type containing type parameters.&#xA;For reasons that will become obvious in a bit, type parameters&#xA;are sometimes also called &lt;em&gt;type variables&lt;/em&gt;.&#xA;Type pattern matching allows us to infer the types that need&#xA;to go into these type variables.&#xA;Let&amp;rsquo;s consider a short example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;Sort&lt;/code&gt; function call passes the &lt;code&gt;list&lt;/code&gt; variable as function argument for the parameter &lt;code&gt;x&lt;/code&gt;&#xA;of &lt;a href=&#34;https://pkg.go.dev/slices#Sort&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;slices.Sort&lt;/code&gt;&lt;/a&gt;.&#xA;Therefore the type of &lt;code&gt;list&lt;/code&gt;, which is &lt;code&gt;List&lt;/code&gt;, must match the type of &lt;code&gt;x&lt;/code&gt;, which is type parameter &lt;code&gt;S&lt;/code&gt;.&#xA;If &lt;code&gt;S&lt;/code&gt; has the type &lt;code&gt;List&lt;/code&gt;, this assignment becomes valid.&#xA;In reality, the &lt;a href=&#34;https://go.dev/ref/spec#Assignability&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;rules for assignments&lt;/a&gt; are complicated,&#xA;but for now it&amp;rsquo;s good enough to assume that the types must be identical.&lt;/p&gt;&#xA;&lt;p&gt;Once we have inferred the type for &lt;code&gt;S&lt;/code&gt;, we can look at the&#xA;&lt;a href=&#34;https://go.dev/ref/spec#Type_constraints&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;type constraint&lt;/a&gt; for &lt;code&gt;S&lt;/code&gt;.&#xA;It says—because of the tilde &lt;code&gt;~&lt;/code&gt; symbol—that the&#xA;&lt;a href=&#34;https://go.dev/ref/spec#Underlying_types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;underlying type&lt;/em&gt;&lt;/a&gt; of &lt;code&gt;S&lt;/code&gt;&#xA;must be the slice &lt;code&gt;[]E&lt;/code&gt;.&#xA;The underlying type of &lt;code&gt;S&lt;/code&gt; is &lt;code&gt;[]int&lt;/code&gt;, therefore &lt;code&gt;[]int&lt;/code&gt; must match &lt;code&gt;[]E&lt;/code&gt;,&#xA;and with that we can conclude that &lt;code&gt;E&lt;/code&gt; must be &lt;code&gt;int&lt;/code&gt;.&#xA;We&amp;rsquo;ve been able to find types for &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; such that corresponding types match.&#xA;Inference has succeeded!&lt;/p&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s a more complicated scenario where we have a lot of type parameters:&#xA;&lt;code&gt;S1&lt;/code&gt;, &lt;code&gt;S2&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, and &lt;code&gt;E2&lt;/code&gt; from &lt;code&gt;slices.EqualFunc&lt;/code&gt;, and &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt; from the generic function &lt;code&gt;equal&lt;/code&gt;.&#xA;The local function &lt;code&gt;foo&lt;/code&gt; calls &lt;code&gt;slices.EqualFunc&lt;/code&gt; with the &lt;code&gt;equal&lt;/code&gt; function as an argument:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool&#xA;&#xA;// Local code&#xA;func equal[E1, E2 comparable](E1, E2) bool { … }&#xA;&#xA;func foo(list1 []int, list2 []float64) {&#xA;    …&#xA;    if slices.EqualFunc(list1, list2, equal) {&#xA;        …&#xA;    }&#xA;    …&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is an example where type inference really shines as we can potentially leave away six type arguments,&#xA;one for each of the type parameters.&#xA;The type pattern matching approach still works, but we can see how it may get complicated quickly&#xA;because the number of type relationships is proliferating.&#xA;We need a systematic approach to determine which type parameters and which types get involved with which patterns.&lt;/p&gt;&#xA;&lt;p&gt;It helps to look at type inference in a slightly different way.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-equations&#34;&gt;Type equations&lt;/h2&gt;&#xA;&lt;p&gt;We can reframe type inference as a problem of solving type equations.&#xA;Solving equations is something that we are all familiar with from high school algebra.&#xA;Luckily, solving type equations is a simpler problem as we will see shortly.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s look again at our earlier example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;type List []int&#xA;var list List&#xA;slices.Sort(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Inference succeeds if the type equations below can be solved.&#xA;Here &lt;code&gt;≡&lt;/code&gt; stands for &lt;a href=&#34;https://go.dev/ref/spec#Type_identity&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;is identical to&lt;/em&gt;&lt;/a&gt;,&#xA;and &lt;code&gt;under(S)&lt;/code&gt; represents&#xA;the &lt;a href=&#34;https://go.dev/ref/spec#Underlying_types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;underlying type&lt;/a&gt;&#xA;of &lt;code&gt;S&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S ≡ List        // find S such that S ≡ List is true&#xA;under(S) ≡ []E  // find E such that under(S) ≡ []E is true&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The type parameters are the &lt;em&gt;variables&lt;/em&gt; in the equations.&#xA;Solving the equations means finding values (type arguments) for these variables&#xA;(type parameters), such that the equations become true.&#xA;This view makes the type inference problem more tractable because&#xA;it gives us a formal framework that allows us to write down the information that&#xA;flows into inference.&lt;/p&gt;&#xA;&lt;h3 id=&#34;being-precise-with-type-relations&#34;&gt;Being precise with type relations&lt;/h3&gt;&#xA;&lt;p&gt;Until now we have simply talked about types having to be&#xA;&lt;a href=&#34;https://go.dev/ref/spec#Type_identity&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;identical&lt;/a&gt;.&#xA;But for actual Go code that is too strong a requirement.&#xA;In the previous example, &lt;code&gt;S&lt;/code&gt; need not be identical to &lt;code&gt;List&lt;/code&gt;,&#xA;rather &lt;code&gt;List&lt;/code&gt; must be &lt;a href=&#34;https://go.dev/ref/spec#Assignability&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;assignable&lt;/a&gt; to &lt;code&gt;S&lt;/code&gt;.&#xA;Similarly, &lt;code&gt;S&lt;/code&gt; must &lt;a href=&#34;https://go.dev/ref/spec#Satisfying_a_type_constraint&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;satisfy&lt;/a&gt;&#xA;its corresponding type constraint.&#xA;We can formulate our type equations more precisely by using specific operators that&#xA;we write as &lt;code&gt;:≡&lt;/code&gt; and &lt;code&gt;∈&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S :≡ List         // List is assignable to S&#xA;S ∈ ~[]E          // S satisfies constraint ~[]E&#xA;E ∈ cmp.Ordered   // E satisfies constraint cmp.Ordered&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Generally, we can say that type equations come in three forms:&#xA;two types must be identical, one type must be assignable to the other type,&#xA;or one type must satisfy a type constraint:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;X ≡ Y             // X and Y must be identical&#xA;X :≡ Y            // Y is assignable to X&#xA;X ∈ Y             // X satisfies constraint Y&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;(Note: In the GopherCon talk we used the symbols &lt;code&gt;≡&lt;/code&gt;&lt;sub&gt;A&lt;/sub&gt; for &lt;code&gt;:≡&lt;/code&gt; and&#xA;&lt;code&gt;≡&lt;/code&gt;&lt;sub&gt;C&lt;/sub&gt; for &lt;code&gt;∈&lt;/code&gt;.&#xA;We believe &lt;code&gt;:≡&lt;/code&gt; more clearly evokes an assignment relation;&#xA;and &lt;code&gt;∈&lt;/code&gt; directly expresses that the type represented by a type parameter must&#xA;be an element of its constraint&amp;rsquo;s &lt;a href=&#34;https://go.dev/ref/spec#Interface_types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;type set&lt;/a&gt;.)&lt;/p&gt;&#xA;&lt;h3 id=&#34;sources-of-type-equations&#34;&gt;Sources of type equations&lt;/h3&gt;&#xA;&lt;p&gt;In a generic function call we may have explicit type arguments,&#xA;though most of the time we hope that they can be inferred.&#xA;Typically we also have ordinary function arguments.&#xA;Each explicit type argument contributes a (trivial) type equation:&#xA;the type parameter must be identical to the type argument because the code says so.&#xA;Each ordinary function argument contributes another type equation:&#xA;the function argument must be assignable to its corresponding function parameter.&#xA;And finally, each type constraint provides a type equation as well&#xA;by constraining what types satisfy the constraint.&lt;/p&gt;&#xA;&lt;p&gt;Altogether, this produces &lt;code&gt;n&lt;/code&gt; type parameters and &lt;code&gt;m&lt;/code&gt; type equations.&#xA;In contrast to basic high school algebra, &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; don&amp;rsquo;t have to be the same for&#xA;type equations to be solvable.&#xA;For instance, the single equation below allows us to infer the type arguments for&#xA;two type parameters:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;map[K]V ≡ map[int]string  // K ➞ int, V ➞ string (n = 2, m = 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s look at each of these sources of type equations in turn:&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-type-equations-from-type-arguments&#34;&gt;1. Type equations from type arguments&lt;/h4&gt;&#xA;&lt;p&gt;For each type parameter declaration&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func f[…, P constraint, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;and explicitly provided type argument&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;f[…, A, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;we get the type equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ≡ A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can trivially solve this for &lt;code&gt;P&lt;/code&gt;: &lt;code&gt;P&lt;/code&gt; must be &lt;code&gt;A&lt;/code&gt; and we write &lt;code&gt;P ➞ A&lt;/code&gt;.&#xA;In other words, there is nothing to do here.&#xA;We could still write down the respective type equation for completeness,&#xA;but in this case, the Go compiler simply substitutes the type arguments&#xA;for their type parameters throughout and then those type parameters are&#xA;gone and we can forget about them.&lt;/p&gt;&#xA;&lt;h4 id=&#34;2-type-equations-from-assignments&#34;&gt;2. Type equations from assignments&lt;/h4&gt;&#xA;&lt;p&gt;For each function argument &lt;code&gt;x&lt;/code&gt; passed to a function parameter &lt;code&gt;p&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;f(…, x, …)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; contain type parameters,&#xA;the type of &lt;code&gt;x&lt;/code&gt; must be assignable to the type of the parameter &lt;code&gt;p&lt;/code&gt;.&#xA;We can express this with the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(p) :≡ 𝑻(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where &lt;code&gt;𝑻(x)&lt;/code&gt; means &amp;ldquo;the type of &lt;code&gt;x&lt;/code&gt;&amp;rdquo;.&#xA;If neither &lt;code&gt;p&lt;/code&gt; nor &lt;code&gt;x&lt;/code&gt; contains type parameters, there is no type variable to solve for:&#xA;the equation is either true because the assignment is valid Go code,&#xA;or false if the code is invalid.&#xA;For this reason, type inference only considers types that contain type parameters of the&#xA;involved function (or functions).&lt;/p&gt;&#xA;&lt;p&gt;Starting with Go 1.21, an uninstantiated or partially instantiated function&#xA;(but not a function call) may also be assigned to a function-typed variable, as in:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;var intSort func([]int) = slices.Sort&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Analogous to parameter passing, such assignments lead to a corresponding&#xA;type equation. For this example it would be&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(intSort) :≡ 𝑻(slices.Sort)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;or simplified&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func([]int) :≡ func(S)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;together with equations for the constraints for &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; from &lt;code&gt;slices.Sort&lt;/code&gt;&#xA;(see below).&lt;/p&gt;&#xA;&lt;h4 id=&#34;3-type-equations-from-constraints&#34;&gt;3. Type equations from constraints&lt;/h4&gt;&#xA;&lt;p&gt;Finally, for each type parameter &lt;code&gt;P&lt;/code&gt; for which we want to infer a type argument,&#xA;we can extract a type equation from its constraint because the type parameter&#xA;must satisfy the constraint. Given the declaration&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func f[…, P constraint, …]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;we can write down the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ∈ constraint&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Here, the &lt;code&gt;∈&lt;/code&gt; means &amp;ldquo;must satisfy constraint&amp;rdquo; which is (almost) the same as&#xA;being a type element of the constraint&amp;rsquo;s type set.&#xA;We will see later that some constraints (such as &lt;code&gt;any&lt;/code&gt;) are not useful or&#xA;currently cannot be used due to limitations of the implementation.&#xA;Inference simply ignores the respective equations in those cases.&lt;/p&gt;&#xA;&lt;h3 id=&#34;type-parameters-and-equations-may-be-from-multiple-functions&#34;&gt;Type parameters and equations may be from multiple functions&lt;/h3&gt;&#xA;&lt;p&gt;In Go 1.18, inferred type parameters had to all be from the same function.&#xA;Specifically, it was not possible to pass a generic, uninstantiated or partially instantiated&#xA;function as a function argument,&#xA;or assign it to a (function-typed) variable.&lt;/p&gt;&#xA;&lt;p&gt;As mentioned earlier, in Go 1.21 type inference also works in these cases.&#xA;For instance, the generic function&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func myEq[P comparable](x, y P) bool { return x == y }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;can be assigned to a variable of function type&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;var strEq func(x, y string) bool = myEq  // same as using myEq[string]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without &lt;code&gt;myEq&lt;/code&gt; being fully instantiated,&#xA;and type inference will infer that the type argument for &lt;code&gt;P&lt;/code&gt; must be &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Furthermore, a generic function may be used uninstantiated or partially instantiated as&#xA;an argument to another, possibly generic function:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S&#xA;&#xA;type List []int&#xA;var list List&#xA;result := slices.CompactFunc(list, myEq)  // same as using slices.CompactFunc[List, int](list, myEq[int])&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this last example, type inference determines the type arguments for &lt;code&gt;CompactFunc&lt;/code&gt;&#xA;and &lt;code&gt;myEq&lt;/code&gt;.&#xA;More generally, type parameters from arbitrarily many functions may need to be inferred.&#xA;With multiple functions involved, type equations may also be from or involve multiple functions.&#xA;In the &lt;code&gt;CompactFunc&lt;/code&gt; example we end up with three type parameters and five type equations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Type parameters and constraints:&#xA;    S ~[]E&#xA;    E any&#xA;    P comparable&#xA;&#xA;Explicit type arguments:&#xA;    none&#xA;&#xA;Type equations:&#xA;    S :≡ List&#xA;    func(E, E) bool :≡ func(P, P) bool&#xA;    S ∈ ~[]E&#xA;    E ∈ any&#xA;    P ∈ comparable&#xA;&#xA;Solution:&#xA;    S ➞ List&#xA;    E ➞ int&#xA;    P ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;bound-vs-free-type-parameters&#34;&gt;Bound vs free type parameters&lt;/h3&gt;&#xA;&lt;p&gt;At this point we have a clearer understanding of the various source of type equations,&#xA;but we have not been very precise about which type parameters to solve the equations for.&#xA;Let&amp;rsquo;s consider another example.&#xA;In the code below, the function body of &lt;code&gt;sortedPrint&lt;/code&gt; calls &lt;code&gt;slices.Sort&lt;/code&gt; for the sorting part.&#xA;&lt;code&gt;sortedPrint&lt;/code&gt; and &lt;code&gt;slices.Sort&lt;/code&gt; are generic functions as both declare type parameters.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// From the slices package&#xA;// func Sort[S ~[]E, E cmp.Ordered](x S)&#xA;&#xA;// sortedPrint prints the elements of the provided list in sorted order.&#xA;func sortedPrint[F any](list []F) {&#xA;    slices.Sort(list)  // 𝑻(list) is []F&#xA;    …                  // print list&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We want to infer the type argument for the &lt;code&gt;slices.Sort&lt;/code&gt; call.&#xA;Passing &lt;code&gt;list&lt;/code&gt; to parameter &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;slices.Sort&lt;/code&gt; gives rise to the equation&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(x) :≡ 𝑻(list)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;which is the same as&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;S :≡ []F&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In this equation we have two type parameters, &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt;.&#xA;Which one do we need to solve the type equation for?&#xA;Because the invoked function is &lt;code&gt;Sort&lt;/code&gt;, we care about its type parameter &lt;code&gt;S&lt;/code&gt;,&#xA;not the type parameter &lt;code&gt;F&lt;/code&gt;.&#xA;We say that &lt;code&gt;S&lt;/code&gt; is &lt;em&gt;bound&lt;/em&gt; to &lt;code&gt;Sort&lt;/code&gt; because it is declared by &lt;code&gt;Sort&lt;/code&gt;.&#xA;&lt;code&gt;S&lt;/code&gt; is the relevant type variable in this equation.&#xA;By contrast, &lt;code&gt;F&lt;/code&gt; is bound to (declared by) &lt;code&gt;sortedPrint&lt;/code&gt;.&#xA;We say that &lt;code&gt;F&lt;/code&gt; is &lt;em&gt;free&lt;/em&gt; with respect to &lt;code&gt;Sort&lt;/code&gt;.&#xA;It has its own, already given type.&#xA;That type is &lt;code&gt;F&lt;/code&gt;, whatever that is (determined at instantiation time).&#xA;In this equation, &lt;code&gt;F&lt;/code&gt; is already given, it is a &lt;em&gt;type constant&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;p&gt;When solving type equations we always solve for the type parameters&#xA;bound to the function we are calling&#xA;(or assigning in case of a generic function assignment).&lt;/p&gt;&#xA;&lt;h2 id=&#34;solving-type-equations&#34;&gt;Solving type equations&lt;/h2&gt;&#xA;&lt;p&gt;The missing piece, now that we have established how to collect the relevant&#xA;type parameters and type equations, is of course the algorithm that allows&#xA;us to solve the equations.&#xA;After the various examples, it probably has become obvious that solving&#xA;&lt;code&gt;X ≡ Y&lt;/code&gt; simply means comparing the types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; recursively against&#xA;each other, and in the process determining suitable type arguments for&#xA;type parameters that may occur in &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;.&#xA;The goal is to make the types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; &lt;em&gt;identical&lt;/em&gt;.&#xA;This matching process is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Unification_(computer_science)&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;unification&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The rules for &lt;a href=&#34;https://go.dev/ref/spec#Type_identity&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;type identity&lt;/a&gt; tell&#xA;us how to compare types.&#xA;Since &lt;em&gt;bound&lt;/em&gt; type parameters play the role of type variables, we need&#xA;to specify how they are matched against other types.&#xA;The rules are as follows:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;If type parameter &lt;code&gt;P&lt;/code&gt; has an inferred type, &lt;code&gt;P&lt;/code&gt; stands for that type.&lt;/li&gt;&#xA;&lt;li&gt;If type parameter &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have an inferred type and is matched against another type&#xA;&lt;code&gt;T&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt; is set to that type: &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;We say that the type &lt;code&gt;T&lt;/code&gt; was inferred for &lt;code&gt;P&lt;/code&gt;.&lt;/li&gt;&#xA;&lt;li&gt;If &lt;code&gt;P&lt;/code&gt; matches against another type parameter &lt;code&gt;Q&lt;/code&gt;, and neither &lt;code&gt;P&lt;/code&gt; nor &lt;code&gt;Q&lt;/code&gt;&#xA;have an inferred type yet, &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are &lt;em&gt;unified&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Unification of two type parameters means that they are joined together such&#xA;that going forward they both denote the same type parameter value:&#xA;if one of &lt;code&gt;P&lt;/code&gt; or &lt;code&gt;Q&lt;/code&gt; is matched against a type &lt;code&gt;T&lt;/code&gt;, both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;Q&lt;/code&gt; are&#xA;set to &lt;code&gt;T&lt;/code&gt; simultaneously&#xA;(in general, any number of type parameters may be unified this way).&lt;/p&gt;&#xA;&lt;p&gt;Finally, if two types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are different, the equation cannot be made&#xA;true and solving it fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;unifying-types-for-type-identity&#34;&gt;Unifying types for type identity&lt;/h3&gt;&#xA;&lt;p&gt;A few concrete examples should make this algorithm clear.&#xA;Consider two types &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; containing three bound type parameters &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;,&#xA;all appearing in the type equation &lt;code&gt;X ≡ Y&lt;/code&gt;.&#xA;The goal is to the solve this equation for the type parameters; i.e., find suitable&#xA;type arguments for them such that &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; become identical and thus the equation&#xA;becomes true.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []B}&#xA;Y: map[string]struct{i C; s []byte}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unification proceeds by comparing the structure of &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; recursively, starting at the top.&#xA;Simply looking at the structure of the two types we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;map[…]… ≡ map[…]…&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;with the &lt;code&gt;…&lt;/code&gt; representing the respective map key and value types that we&amp;rsquo;re&#xA;ignoring at this step.&#xA;Since we have a map on both sides, the types are identical so far.&#xA;Unification proceeds recursively, first with the key types which are &lt;code&gt;A&lt;/code&gt; for the &lt;code&gt;X&lt;/code&gt; map,&#xA;and &lt;code&gt;string&lt;/code&gt; for the &lt;code&gt;Y&lt;/code&gt; map.&#xA;Corresponding key types must be identical, and from that we can immediately infer that&#xA;the type argument for &lt;code&gt;A&lt;/code&gt; must be &lt;code&gt;string&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A ≡ string =&amp;gt; A ➞ string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Continuing with the map element types, we arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;struct{i int; s []B} ≡ struct{i C; s []byte}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Both sides are structs so unification proceeds with the struct fields.&#xA;They are identical if they are in the same order, with the same names, and identical types.&#xA;The first field pair is &lt;code&gt;i int&lt;/code&gt; and &lt;code&gt;i C&lt;/code&gt;.&#xA;The names match and because &lt;code&gt;int&lt;/code&gt; must unify with &lt;code&gt;C&lt;/code&gt;, thus&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;int ≡ C =&amp;gt; C ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This recursive type matching continues until the tree structure of the two types is fully&#xA;traversed, or until a conflict appears.&#xA;In this example, eventually we end up with&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;[]B ≡ []byte =&amp;gt; B ≡ byte =&amp;gt; B ➞ byte&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Everything works out fine and unification infers the type arguments&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;A ➞ string&#xA;B ➞ byte&#xA;C ➞ int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;unifying-types-with-different-structures&#34;&gt;Unifying types with different structures&lt;/h3&gt;&#xA;&lt;p&gt;Now, let&amp;rsquo;s consider a slight variation of the previous example:&#xA;here &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; don&amp;rsquo;t have the same type structure.&#xA;When the type trees are compared recursively, unification still successfully infers the type argument for &lt;code&gt;A&lt;/code&gt;.&#xA;But the value types of the maps are different and unification fails.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []B}&#xA;Y: map[string]bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Both &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are map types, so unification proceeds recursively as before, starting with the key types.&#xA;We arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A ≡ string =&amp;gt; A ➞ string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;also as before.&#xA;But when we proceed with the map&amp;rsquo;s value types we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;struct{…} ≡ bool&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;struct&lt;/code&gt; type doesn&amp;rsquo;t match &lt;code&gt;bool&lt;/code&gt;; we have different types and unification (and thus type inference) fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;unifying-types-with-conflicting-type-arguments&#34;&gt;Unifying types with conflicting type arguments&lt;/h3&gt;&#xA;&lt;p&gt;Another kind of conflict appears when different types match against the same type parameter.&#xA;Here we have again a version of our initial example but now the type parameter &lt;code&gt;A&lt;/code&gt; appears twice in &lt;code&gt;X&lt;/code&gt;,&#xA;and &lt;code&gt;C&lt;/code&gt; appears twice in &lt;code&gt;Y&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;X: map[A]struct{i int; s []A}&#xA;Y: map[string]struct{i C; s []C}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The recursive type unification works out fine at first and we have the following pairings of type&#xA;parameters and types:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;A   ≡ string =&amp;gt; A ➞ string  // map key type&#xA;int ≡ C      =&amp;gt; C ➞ int     // first struct field type&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;When we get to the second struct field type we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;[]A ≡ []C =&amp;gt; A ≡ C&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Since both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have a type argument inferred for them, they stand for those type arguments,&#xA;which are &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; respectively.&#xA;These are different types, so &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; can&amp;rsquo;t possibly match.&#xA;Unification and thus type inference fails.&lt;/p&gt;&#xA;&lt;h3 id=&#34;other-type-relations&#34;&gt;Other type relations&lt;/h3&gt;&#xA;&lt;p&gt;Unification solves type equations of the form &lt;code&gt;X ≡ Y&lt;/code&gt; where the goal is &lt;em&gt;type identity&lt;/em&gt;.&#xA;But what about &lt;code&gt;X :≡ Y&lt;/code&gt; or &lt;code&gt;X ∈ Y&lt;/code&gt;?&lt;/p&gt;&#xA;&lt;p&gt;A couple of observations help us out here:&#xA;The job of type inference is solely to find the types of omitted type arguments.&#xA;Type inference is always followed by type or function&#xA;&lt;a href=&#34;https://go.dev/ref/spec#Instantiations&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;instantiation&lt;/a&gt; which&#xA;checks that each type argument actually satisfies its respective type constraint.&#xA;Finally, in case of a generic function call, the compiler also checks that&#xA;function arguments are assignable to their corresponding function parameters.&#xA;All of these steps must succeed for the code to be valid.&lt;/p&gt;&#xA;&lt;p&gt;If type inference is not precise enough it may infer an (incorrect) type argument&#xA;where no type may exist.&#xA;If that is the case, either instantiation or argument passing will fail.&#xA;Either way, the compiler will produce an error message.&#xA;It&amp;rsquo;s just that the error message may be slightly different.&lt;/p&gt;&#xA;&lt;p&gt;This insight allows us to play a bit loose with the type relations &lt;code&gt;:≡&lt;/code&gt; and &lt;code&gt;∈&lt;/code&gt;.&#xA;Specifically, it allows us to simplify them such that they can be treated&#xA;almost the same as &lt;code&gt;≡&lt;/code&gt;.&#xA;The goal of the simplifications is to extract as much type information as&#xA;possible from a type equation, and thus to infer type arguments where a&#xA;precise implementation may fail, because we can.&lt;/p&gt;&#xA;&lt;h3 id=&#34;simplifying-x--y&#34;&gt;Simplifying X :≡ Y&lt;/h3&gt;&#xA;&lt;p&gt;Go&amp;rsquo;s assignability rules are pretty complicated, but most of the time we can actually&#xA;get by with type identity, or a slight variation of it.&#xA;As long as we find potential type arguments, we&amp;rsquo;re happy, exactly because type inference&#xA;is still followed by type instantiation and function invocation.&#xA;If inference finds a type argument where it shouldn&amp;rsquo;t, it&amp;rsquo;ll be caught later.&#xA;Thus, when matching for assignability, we make the following adjustments to the&#xA;unfication algorithm:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;When a named (defined) type is matched against a type literal,&#xA;their underlying types are compared instead.&lt;/li&gt;&#xA;&lt;li&gt;When comparing channel types, channel directions are ignored.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Furthermore, the assignment direction is ignored: &lt;code&gt;X :≡ Y&lt;/code&gt; is treated like &lt;code&gt;Y :≡ X&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;These adjustments apply only at the top level of a type structure:&#xA;for instance, per Go&amp;rsquo;s &lt;a href=&#34;https://go.dev/ref/spec#Assignability&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;assignability rules&lt;/a&gt;,&#xA;a named map type may be assigned to an unnamed map type, but the key and element types&#xA;must still be identical.&#xA;With these changes, unification for assignability becomes a (minor) variation&#xA;of unification for type identity.&#xA;The following example illustrates this.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s assume we are passing a value of our earlier &lt;code&gt;List&lt;/code&gt; type (defined as &lt;code&gt;type List []int&lt;/code&gt;)&#xA;to a function parameter of type &lt;code&gt;[]E&lt;/code&gt; where &lt;code&gt;E&lt;/code&gt; is a bound type parameter (i.e., &lt;code&gt;E&lt;/code&gt; is declared&#xA;by the generic function that is being called).&#xA;This leads to the type equation &lt;code&gt;[]E :≡ List&lt;/code&gt;.&#xA;Attempting to unify these two types requires comparing &lt;code&gt;[]E&lt;/code&gt; with &lt;code&gt;List&lt;/code&gt;&#xA;These two types are not identical, and without any changes to how unification works,&#xA;it will fail.&#xA;But because we are unifying for assignability, this initial match doesn&amp;rsquo;t need to be exact.&#xA;There&amp;rsquo;s no harm in continuing with the underlying type of the named type &lt;code&gt;List&lt;/code&gt;:&#xA;in the worst case we may infer an incorrect type argument, but that will lead to an error&#xA;later, when assignments are checked.&#xA;In the best case, we find a useful and correct type argument.&#xA;In our example, inexact unification succeeds and we correctly infer &lt;code&gt;int&lt;/code&gt; for &lt;code&gt;E&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;simplifying-x--y-1&#34;&gt;Simplifying X ∈ Y&lt;/h3&gt;&#xA;&lt;p&gt;Being able to simplify the constraint satisfaction relation is even more important as&#xA;constraints can be very complex.&lt;/p&gt;&#xA;&lt;p&gt;Again, constraint satisfaction is checked at instantiation time, so the goal here is&#xA;to help type inference where we can.&#xA;These are typically situations where we know the structure of a type parameter;&#xA;for instance we know that it must be a&#xA;slice type and we care about the slice&amp;rsquo;s element type.&#xA;For example, a type parameter list of the form &lt;code&gt;[P ~[]E]&lt;/code&gt; tells us that whatever &lt;code&gt;P&lt;/code&gt; is,&#xA;its underlying type must be of the form &lt;code&gt;[]E&lt;/code&gt;.&#xA;These are exactly the situations where the constraint has a&#xA;&lt;a href=&#34;https://go.dev/ref/spec#Core_types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;core type&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Therefore, if we have an equation of the form&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P ∈ constraint               // or&#xA;P ∈ ~constraint&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;and if &lt;code&gt;core(constraint)&lt;/code&gt; (or &lt;code&gt;core(~constraint)&lt;/code&gt;, respectively) exists, the equation&#xA;can be simplified to&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;P        ≡ core(constraint)&#xA;under(P) ≡ core(~constraint)  // respectively&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In all other cases, type equations involving constraints are ignored.&lt;/p&gt;&#xA;&lt;h3 id=&#34;expanding-inferred-types&#34;&gt;Expanding inferred types&lt;/h3&gt;&#xA;&lt;p&gt;If unification is successful it produces a mapping from type parameters&#xA;to inferred type arguments.&#xA;But unification alone doesn&amp;rsquo;t ensure that the inferred types are free&#xA;of bound type parameters.&#xA;To see why this is the case, consider the generic function &lt;code&gt;g&lt;/code&gt; below&#xA;which is invoked with a single argument &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func g[A any, B []C, C *A](x A) { … }&#xA;&#xA;var x int&#xA;g(x)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The type constraint for &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; which doesn&amp;rsquo;t have a core type, so we&#xA;ignore it. The remaining type constraints have core types and they are &lt;code&gt;[]C&lt;/code&gt;&#xA;and &lt;code&gt;*A&lt;/code&gt; respectively. Together with the argument passed to &lt;code&gt;g&lt;/code&gt;, after minor&#xA;simplifications, the type equations are:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A :≡ int&#xA;    B ≡ []C&#xA;    C ≡ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Since each equation pits a type parameter against a non-type parameter type,&#xA;unification has little to do and immediately infers&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []C&#xA;    C ➞ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;But that leaves the type parameters &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; in the inferred types, which&#xA;is not helpful.&#xA;Like in high school algebra, once an equation is solved for a variable &lt;code&gt;x&lt;/code&gt;,&#xA;we need to substitute &lt;code&gt;x&lt;/code&gt; with its value throughout the remaining equations.&#xA;In our example, in a first step, the &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;[]C&lt;/code&gt; is substituted with the&#xA;inferred type (the &amp;ldquo;value&amp;rdquo;) for &lt;code&gt;C&lt;/code&gt;, which is &lt;code&gt;*A&lt;/code&gt;, and we arrive at&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []*A    // substituted *A for C&#xA;    C ➞ *A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In two more steps we replace the &lt;code&gt;A&lt;/code&gt; in the inferred types &lt;code&gt;[]*A&lt;/code&gt; and &lt;code&gt;*A&lt;/code&gt;&#xA;with the inferred type for &lt;code&gt;A&lt;/code&gt;, which is &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    A ➞ int&#xA;    B ➞ []*int  // substituted int for A&#xA;    C ➞ *int    // substituted int for A&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Only now inference is done.&#xA;And like in high school algebra, sometimes this doesn&amp;rsquo;t work.&#xA;It&amp;rsquo;s possible to arrive at a situation such as&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ Y&#xA;    Y ➞ *X&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;After one round of substitutions we have&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ *X&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If we keep going, the inferred type for &lt;code&gt;X&lt;/code&gt; keeps growing:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    X ➞ **X     // substituted *X for X&#xA;    X ➞ ***X    // substituted *X for X&#xA;    etc.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Type inference detects such cycles during expansion and reports&#xA;an error (and thus fails).&lt;/p&gt;&#xA;&lt;h2 id=&#34;untyped-constants&#34;&gt;Untyped constants&lt;/h2&gt;&#xA;&lt;p&gt;By now we have seen how type inference works by solving type equations&#xA;with unification, followed by expansion of the result.&#xA;But what if there are no types?&#xA;What if the function arguments are untyped constants?&lt;/p&gt;&#xA;&lt;p&gt;Another example helps us shed light on this situation.&#xA;Let&amp;rsquo;s consider a function &lt;code&gt;foo&lt;/code&gt; which takes an arbitrary number of arguments,&#xA;all of which must have the same type.&#xA;&lt;code&gt;foo&lt;/code&gt; is called with a variety of untyped constant arguments, including a variable&#xA;&lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func foo[P any](...P) {}&#xA;&#xA;var x int&#xA;foo(x)         // P ➞ int, same as foo[int](x)&#xA;foo(x, 2.0)    // P ➞ int, 2.0 converts to int without loss of precision&#xA;foo(x, 2.1)    // P ➞ int, but parameter passing fails: 2.1 is not assignable to int&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For type inference, typed arguments take precedence over untyped arguments.&#xA;An untyped constant is considered for inference only if the type parameter it&amp;rsquo;s assigned&#xA;to doesn&amp;rsquo;t have an inferred type yet.&#xA;In these first three calls to &lt;code&gt;foo&lt;/code&gt;, the variable &lt;code&gt;x&lt;/code&gt; determines the inferred type for &lt;code&gt;P&lt;/code&gt;:&#xA;it&amp;rsquo;s the type of &lt;code&gt;x&lt;/code&gt; which is &lt;code&gt;int&lt;/code&gt;.&#xA;Untyped constants are ignored for type inference in this case and the calls behave exactly&#xA;as if &lt;code&gt;foo&lt;/code&gt; was explicitly instantiated with &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;It gets more interesting if &lt;code&gt;foo&lt;/code&gt; is called with untyped constant arguments only.&#xA;In this case, type inference considers the &lt;a href=&#34;https://go.dev/ref/spec#Constants&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;default types&lt;/a&gt;&#xA;of the untyped constants.&#xA;As a quick reminder, here are the possible default types in Go:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Example     Constant kind              Default type    Order&#xA;&#xA;true        boolean constant           bool&#xA;42          integer constant           int             earlier in list&#xA;&#39;x&#39;         rune constant              rune               |&#xA;3.1416      floating-point constant    float64            v&#xA;-1i         complex constant           complex128      later in list&#xA;&amp;quot;gopher&amp;quot;    string constant            string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;With this information in hand, let&amp;rsquo;s consider the function call&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2)    // P ➞ int (default type for 1 and 2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The untyped constant arguments &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; are both integer constants, their default type is&#xA;&lt;code&gt;int&lt;/code&gt; and thus it&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; that is inferred for the type parameter &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If different constants—say untyped integer and floating-point constants—compete&#xA;for the same type variable, we have different default types.&#xA;Before Go 1.21, this was considered a conflict and led to an error:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2.0)    // Go 1.20: inference error: default types int, float64 don&#39;t match&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This behavior was not very ergonomic in use and also different from the behavior of untyped constants&#xA;in expressions. For instance, Go permits the constant expression &lt;code&gt;1 + 2.0&lt;/code&gt;;&#xA;the result is the floating-point constant &lt;code&gt;3.0&lt;/code&gt; with default type &lt;code&gt;float64&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In Go 1.21 the behavior was changed accordingly.&#xA;Now, if multiple untyped numeric constants are matched against the same type parameter,&#xA;the default type that appears later in the list of &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;rune&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt; is&#xA;selected, matching the rules for &lt;a href=&#34;https://go.dev/ref/spec#Constant_expressions&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;constant expressions&lt;/a&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;foo(1, 2.0)    // Go 1.21: P ➞ float64 (larger default type of 1 and 2.0; behavior like in 1 + 2.0)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;special-situations&#34;&gt;Special situations&lt;/h2&gt;&#xA;&lt;p&gt;By now we&amp;rsquo;ve got the big picture about type inference.&#xA;But there are a couple of important special situations that deserve some attention.&lt;/p&gt;&#xA;&lt;h3 id=&#34;parameter-order-dependencies&#34;&gt;Parameter order dependencies&lt;/h3&gt;&#xA;&lt;p&gt;The first one has to do with parameter order dependencies.&#xA;An important property we want from type inference is that the same types are inferred&#xA;irrespective of the order of the function parameters (and corresponding argument&#xA;order in each call of that function).&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s reconsider our variadic &lt;code&gt;foo&lt;/code&gt; function:&#xA;the type inferred for &lt;code&gt;P&lt;/code&gt; should be the same irrespective of the order in which&#xA;we pass the arguments &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;t&lt;/code&gt; (&lt;a href=&#34;https://go.dev/play/p/sOlWutKnDFc&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;playground&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func foo[P any](...P) (x P) {}&#xA;&#xA;type T struct{}&#xA;&#xA;func main() {&#xA;    var s struct{}&#xA;    var t T&#xA;    fmt.Printf(&amp;quot;%T\\n&amp;quot;, foo(s, t))&#xA;    fmt.Printf(&amp;quot;%T\\n&amp;quot;, foo(t, s)) // expect same result independent of parameter order&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;From the calls to &lt;code&gt;foo&lt;/code&gt; we can extract the relevant type equations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(x) :≡ 𝑻(s) =&amp;gt; P :≡ struct{}    // equation 1&#xA;𝑻(x) :≡ 𝑻(t) =&amp;gt; P :≡ T           // equation 2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Sadly, the simplified implementation for &lt;code&gt;:≡&lt;/code&gt; produces an order dependency:&lt;/p&gt;&#xA;&lt;p&gt;If unification starts with equation 1, it matches &lt;code&gt;P&lt;/code&gt; against &lt;code&gt;struct&lt;/code&gt;; &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have a type inferred for it yet&#xA;and thus unification infers &lt;code&gt;P ➞ struct{}&lt;/code&gt;.&#xA;When unification sees type &lt;code&gt;T&lt;/code&gt; later in equation 2, it proceeds with the underlying type of &lt;code&gt;T&lt;/code&gt; which is &lt;code&gt;struct{}&lt;/code&gt;,&#xA;&lt;code&gt;P&lt;/code&gt; and &lt;code&gt;under(T)&lt;/code&gt; unify, and unification and thus inference succeeds.&lt;/p&gt;&#xA;&lt;p&gt;Vice versa, if unification starts with equation 2, it matches &lt;code&gt;P&lt;/code&gt; against &lt;code&gt;T&lt;/code&gt;; &lt;code&gt;P&lt;/code&gt; doesn&amp;rsquo;t have a type inferred for it yet&#xA;and thus unification infers &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;When unification sees &lt;code&gt;struct{}&lt;/code&gt; later in equation 1, it proceeds with the underlying type of the type &lt;code&gt;T&lt;/code&gt; inferred for &lt;code&gt;P&lt;/code&gt;.&#xA;That underlying type is &lt;code&gt;struct{}&lt;/code&gt;, which matches &lt;code&gt;struct&lt;/code&gt; in equation 1, and unification and thus inference succeeds.&lt;/p&gt;&#xA;&lt;p&gt;As a consequence, depending on the order in which unification solves the two type equations,&#xA;the inferred type is either &lt;code&gt;struct{}&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;.&#xA;This is of course unsatisfying: a program may suddenly stop compiling simply because arguments&#xA;may have been shuffled around during a code refactoring or cleanup.&lt;/p&gt;&#xA;&lt;h3 id=&#34;restoring-order-independence&#34;&gt;Restoring order independence&lt;/h3&gt;&#xA;&lt;p&gt;Luckily, the remedy is fairly simple.&#xA;All we need is a small correction in some situations.&lt;/p&gt;&#xA;&lt;p&gt;Specifically, if unification is solving &lt;code&gt;P :≡ T&lt;/code&gt; and&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;P&lt;/code&gt; is a type parameter which already has inferred a type &lt;code&gt;A&lt;/code&gt;: &lt;code&gt;P ➞ A&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;A :≡ T&lt;/code&gt; is true&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;T&lt;/code&gt; is a named type&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;then set the inferred type for &lt;code&gt;P&lt;/code&gt; to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;P ➞ T&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;This ensures that &lt;code&gt;P&lt;/code&gt; is the named type if there is choice, no matter at which point the named type&#xA;appeared in a match against &lt;code&gt;P&lt;/code&gt; (i.e., no matter in which order the type equations are solved).&#xA;Note that if different named types match against the same type parameter, we always have a unfication&#xA;failure because different named types are not identical by definition.&lt;/p&gt;&#xA;&lt;p&gt;Because we made similar simplifications for channels and interfaces, they also need similar special&#xA;handling. For instance, we ignore channel directions when unifying for assignability and as a result&#xA;may infer a directed or bidirectional channel depending on argument order. Similar problems occur&#xA;with interfaces. We&amp;rsquo;re not going to discuss these here.&lt;/p&gt;&#xA;&lt;p&gt;Going back to our example, if unification starts with equation 1, it infers &lt;code&gt;P ➞ struct{}&lt;/code&gt; as before.&#xA;When it proceeds with equation 2, as before, unification succeeds, but now we have exactly the&#xA;condition that calls for a correction: &lt;code&gt;P&lt;/code&gt; is a type parameter which already has a type (&lt;code&gt;struct{}&lt;/code&gt;),&#xA;&lt;code&gt;struct{}&lt;/code&gt;, &lt;code&gt;struct{} :≡ T&lt;/code&gt; is true (because &lt;code&gt;struct{} ≡ under(T)&lt;/code&gt; is true), and &lt;code&gt;T&lt;/code&gt; is a named type.&#xA;Thus, unification makes the correction and sets &lt;code&gt;P ➞ T&lt;/code&gt;.&#xA;As a result, irrespective of the unification order, the result is the same (&lt;code&gt;T&lt;/code&gt;) in both cases.&lt;/p&gt;&#xA;&lt;h3 id=&#34;self-recursive-functions&#34;&gt;Self-recursive functions&lt;/h3&gt;&#xA;&lt;p&gt;Another scenario that causes problems in a naive implementation of inference is self-recursive functions.&#xA;Let&amp;rsquo;s consider a generic factorial function &lt;code&gt;fact&lt;/code&gt;, defined such that it also works for floating-point arguments&#xA;(&lt;a href=&#34;https://go.dev/play/p/s3wXpgHX6HQ&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;playground&lt;/a&gt;).&#xA;Note that this is not a mathematically correct implementation of the&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Gamma_function&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;gamma function&lt;/a&gt;,&#xA;it is simply a convenient example.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return fact(n-1) * n&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The point here is not the factorial function but rather that &lt;code&gt;fact&lt;/code&gt; calls itself with the&#xA;argument &lt;code&gt;n-1&lt;/code&gt; which is of the same type &lt;code&gt;P&lt;/code&gt; as the incoming parameter &lt;code&gt;n&lt;/code&gt;.&#xA;In this call, the type parameter &lt;code&gt;P&lt;/code&gt; is simultaneously a bound and a free type parameter:&#xA;it is bound because it is declared by &lt;code&gt;fact&lt;/code&gt;, the function that we are calling recursively.&#xA;But it is also free because it is declared by the function enclosing the call, which happens&#xA;to also be &lt;code&gt;fact&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The equation resulting from passing the argument &lt;code&gt;n-1&lt;/code&gt; to parameter &lt;code&gt;n&lt;/code&gt; pits &lt;code&gt;P&lt;/code&gt; against itself:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(n) :≡ 𝑻(n-1) =&amp;gt; P :≡ P&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unification sees the same &lt;code&gt;P&lt;/code&gt; on either side of the equation.&#xA;Unification succeeds since both types are identical but there&amp;rsquo;s no information gained and &lt;code&gt;P&lt;/code&gt;&#xA;remains without an inferred type. As a consequence, type inference fails.&lt;/p&gt;&#xA;&lt;p&gt;Luckily, the trick to address this is simple:&#xA;Before type inference is invoked, and for (temporary) use by type inference only,&#xA;the compiler renames the type parameters in the signatures (but not the bodies)&#xA;of all functions involved in the respective call.&#xA;This doesn&amp;rsquo;t change the meaning of the function signatures:&#xA;they denote the same generic functions irrespective of what the names of the type parameters are.&lt;/p&gt;&#xA;&lt;p&gt;For the purpose of this example, let&amp;rsquo;s assume the &lt;code&gt;P&lt;/code&gt; in the signature of &lt;code&gt;fact&lt;/code&gt; got renamed to &lt;code&gt;Q&lt;/code&gt;.&#xA;The effect is as if the recursive call was done indirectly through a &lt;code&gt;helper&lt;/code&gt; function&#xA;(&lt;a href=&#34;https://go.dev/play/p/TLpo-0auWwC&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;playground&lt;/a&gt;):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return helper(n-1) * n&#xA;}&#xA;&#xA;func helper[Q ~int | ~float64](n Q) Q {&#xA;    return fact(n)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;With the renaming, or with the &lt;code&gt;helper&lt;/code&gt; function, the equation resulting from passing&#xA;&lt;code&gt;n-1&lt;/code&gt; to the recursive call of &lt;code&gt;fact&lt;/code&gt; (or the &lt;code&gt;helper&lt;/code&gt; function, respectively) changes&#xA;to&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;𝑻(n) :≡ 𝑻(n-1) =&amp;gt; Q :≡ P&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This equation has two type parameters: the bound type parameter &lt;code&gt;Q&lt;/code&gt;, declared by the&#xA;function that is being called, and the free type parameter &lt;code&gt;P&lt;/code&gt;, declared by the enclosing&#xA;function. This type equation is trivially solved for &lt;code&gt;Q&lt;/code&gt; and results in the inference&#xA;&lt;code&gt;Q ➞ P&lt;/code&gt;&#xA;which is of course what we&amp;rsquo;d expect, and which we can verify by explicitly instantiating&#xA;the recursive call (&lt;a href=&#34;https://go.dev/play/p/zkUFvwJ54lC&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;playground&lt;/a&gt;):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func fact[P ~int | ~float64](n P) P {&#xA;    if n &amp;lt;= 1 {&#xA;        return 1&#xA;    }&#xA;    return fact[P](n-1) * n&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;whats-missing&#34;&gt;What&amp;rsquo;s missing?&lt;/h2&gt;&#xA;&lt;p&gt;Conspicuously absent from our description is type inference for generic types:&#xA;currently generic types must always be explicitly instantiated.&lt;/p&gt;&#xA;&lt;p&gt;There are a couple of reasons for this. First of all, for type instantiation, type inference&#xA;only has type arguments to work with; there are no other arguments as is the case for&#xA;function calls. As a consequence, at least one type argument must always be provided&#xA;(except for pathological cases where type constraints prescribe exactly one possible&#xA;type argument for all type parameters).&#xA;Thus, type inference for types is only useful to complete a partially&#xA;instantiated type where all the omitted type arguments can be inferred from the&#xA;equations resulting from type constraints; i.e., where there are at least two type&#xA;parameters. We believe this is not a very common scenario.&lt;/p&gt;&#xA;&lt;p&gt;Second, and more pertinent, type parameters allow an entirely new kind of recursive&#xA;types. Consider the hypothetical type&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;type T[P T[P]] interface{ … }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;where the constraint for &lt;code&gt;P&lt;/code&gt; is the type being declared.&#xA;Combined with the ablity to have multiple type parameters that may refer to each other&#xA;in complex recursive fashion, type inference becomes much more complicated and we don&amp;rsquo;t&#xA;fully understand all the implications of that at the moment.&#xA;That said, we believe it shouldn&amp;rsquo;t be too hard to detect cycles and proceed with&#xA;type inference where no such cycles exist.&lt;/p&gt;&#xA;&lt;p&gt;Finally, there are situations where type inference is simply not strong enough to make&#xA;an inference, typically because unification works with certain simplifying assumptions&#xA;such as the ones described earlier in this post.&#xA;The primary example here is constraints which have no core type,&#xA;but where a more sophisticated approach might be able to infer type information anyway.&lt;/p&gt;&#xA;&lt;p&gt;These are all areas where we may see incremental improvements in future Go releases.&#xA;Importantly, we believe that cases where inference currently fails are either rare&#xA;or unimportant in production code, and that our current implementation covers a large&#xA;majority of all useful code scenarios.&lt;/p&gt;&#xA;&lt;p&gt;That said, if you run into a situation where you believe type inference should work or&#xA;went astray, please &lt;a href=&#34;https://github.com/golang/go/issues/new/choose&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;file an issue&lt;/a&gt;!&#xA;As always, the Go team loves to hear from you, especially when it helps us making Go&#xA;even better.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/14years&#34;&gt;Fourteen Years of Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Deconstructing Type Parameters</title><id>tag:blog.golang.org,2013:blog.golang.org/deconstructing-type-parameters</id><link rel="alternate" href="https://go.dev/blog/deconstructing-type-parameters"></link><published>2023-09-26T00:00:00+00:00</published><updated>2023-09-26T00:00:00+00:00</updated><author><name></name></author><summary type="html">Why the function signatures in the slices packages are so complicated.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/deconstructing-type-parameters&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Deconstructing Type Parameters&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Ian Lance Taylor&lt;br&gt;&#xA;      26 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;h2 id=&#34;slices-package-function-signatures&#34;&gt;slices package function signatures&lt;/h2&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://pkg.go.dev/slices#Clone&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;slices.Clone&lt;/code&gt;&lt;/a&gt; function is&#xA;pretty simple: it makes a copy of a slice of any type.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[S ~[]E, E any](s S) S {&#xA;    return append(s[:0:0], s...)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This works because appending to a slice with zero capacity will&#xA;allocate a new backing array.&#xA;The function body winds up being shorter than the function signature,&#xA;which is in part because the body is short, but also because the&#xA;signature is long.&#xA;In this blog post we&amp;rsquo;ll explain why the signature is written the way&#xA;that it is.&lt;/p&gt;&#xA;&lt;h2 id=&#34;simple-clone&#34;&gt;Simple Clone&lt;/h2&gt;&#xA;&lt;p&gt;We&amp;rsquo;ll start by writing a simple generic &lt;code&gt;Clone&lt;/code&gt; function.&#xA;This is not the one in the &lt;code&gt;slices&lt;/code&gt; package.&#xA;We want to take a slice of any element type, and return a new slice.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone1[E any](s []E) []E {&#xA;    // body omitted&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The generic function &lt;code&gt;Clone1&lt;/code&gt; has a single type parameter &lt;code&gt;E&lt;/code&gt;.&#xA;It takes a single argument &lt;code&gt;s&lt;/code&gt; which is a slice of type &lt;code&gt;E&lt;/code&gt;, and it&#xA;returns a slice of the same type.&#xA;This signature is straightforward for anybody familiar with generics&#xA;in Go.&lt;/p&gt;&#xA;&lt;p&gt;However, there is a problem.&#xA;Named slice types are not common in Go, but people do use them.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// MySlice is a slice of strings with a special String method.&#xA;type MySlice []string&#xA;&#xA;// String returns the printable version of a MySlice value.&#xA;func (s MySlice) String() string {&#xA;    return strings.Join(s, &amp;quot;+&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s say that we want to make a copy of a &lt;code&gt;MySlice&lt;/code&gt; and then get the&#xA;printable version, but with the strings in sorted order.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func PrintSorted(ms MySlice) string {&#xA;    c := Clone1(ms)&#xA;    slices.Sort(c)&#xA;    return c.String() // FAILS TO COMPILE&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Unfortunately, this doesn&amp;rsquo;t work.&#xA;The compiler reports an error:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;c.String undefined (type []string has no field or method String)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can see the problem if we manually instantiate &lt;code&gt;Clone1&lt;/code&gt; by&#xA;replacing the type parameter with the type argument.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func InstantiatedClone1(s []string) []string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://go.dev/ref/spec#Assignability&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Go assignment rules&lt;/a&gt; allow&#xA;us to pass a value of type &lt;code&gt;MySlice&lt;/code&gt; to a parameter of type&#xA;&lt;code&gt;[]string&lt;/code&gt;, so calling &lt;code&gt;Clone1&lt;/code&gt; is fine.&#xA;But &lt;code&gt;Clone1&lt;/code&gt; will return a value of type &lt;code&gt;[]string&lt;/code&gt;, not a value of&#xA;type &lt;code&gt;MySlice&lt;/code&gt;.&#xA;The type &lt;code&gt;[]string&lt;/code&gt; doesn&amp;rsquo;t have a &lt;code&gt;String&lt;/code&gt; method, so the compiler&#xA;reports an error.&lt;/p&gt;&#xA;&lt;h2 id=&#34;flexible-clone&#34;&gt;Flexible Clone&lt;/h2&gt;&#xA;&lt;p&gt;To fix this problem, we have to write a version of &lt;code&gt;Clone&lt;/code&gt; that&#xA;returns the same type as its argument.&#xA;If we can do that, then when we call &lt;code&gt;Clone&lt;/code&gt; with a value of type&#xA;&lt;code&gt;MySlice&lt;/code&gt;, it will return a result of type &lt;code&gt;MySlice&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We know that it has to look something like this.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone2[S ?](s S) S // INVALID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This &lt;code&gt;Clone2&lt;/code&gt; function returns a value that is the same type as its&#xA;argument.&lt;/p&gt;&#xA;&lt;p&gt;Here I&amp;rsquo;ve written the constraint as &lt;code&gt;?&lt;/code&gt;, but that&amp;rsquo;s just a&#xA;placeholder.&#xA;To make this work we need to write a constraint that will let us write&#xA;the body of the function.&#xA;For &lt;code&gt;Clone1&lt;/code&gt; we could just use a constraint of &lt;code&gt;any&lt;/code&gt; for the element&#xA;type.&#xA;For &lt;code&gt;Clone2&lt;/code&gt; that won&amp;rsquo;t work: we want to require that &lt;code&gt;s&lt;/code&gt; be a slice&#xA;type.&lt;/p&gt;&#xA;&lt;p&gt;Since we know we want a slice, the constraint of &lt;code&gt;S&lt;/code&gt; has to be a&#xA;slice.&#xA;We don&amp;rsquo;t care what the slice element type is, so let&amp;rsquo;s just call it&#xA;&lt;code&gt;E&lt;/code&gt;, as we did with &lt;code&gt;Clone1&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone3[S []E](s S) S // INVALID&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is still invalid, because we haven&amp;rsquo;t declared &lt;code&gt;E&lt;/code&gt;.&#xA;The type argument for &lt;code&gt;E&lt;/code&gt; can be any type, which means it also has to&#xA;be a type parameter itself.&#xA;Since it can be any type, its constraint is &lt;code&gt;any&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone4[S []E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This is getting close, and at least it will compile, but we&amp;rsquo;re not&#xA;quite there yet.&#xA;If we compile this version, we get an error when we call &lt;code&gt;Clone4(ms)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;MySlice does not satisfy []string (possibly missing ~ for []string in []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The compiler is telling us that we can&amp;rsquo;t use the type argument&#xA;&lt;code&gt;MySlice&lt;/code&gt; for the type parameter &lt;code&gt;S&lt;/code&gt;, because &lt;code&gt;MySlice&lt;/code&gt; does not&#xA;satisfy the constraint &lt;code&gt;[]E&lt;/code&gt;.&#xA;That&amp;rsquo;s because &lt;code&gt;[]E&lt;/code&gt; as a constraint only permits a slice type&#xA;literal, like &lt;code&gt;[]string&lt;/code&gt;.&#xA;It doesn&amp;rsquo;t permit a named type like &lt;code&gt;MySlice&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;underlying-type-constraints&#34;&gt;Underlying type constraints&lt;/h2&gt;&#xA;&lt;p&gt;As the error message hints, the answer is to add a &lt;code&gt;~&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone5[S ~[]E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To repeat, writing type parameters and constraints &lt;code&gt;[S []E, E any]&lt;/code&gt;&#xA;means that the type argument for &lt;code&gt;S&lt;/code&gt; can be any unnamed slice type,&#xA;but it can&amp;rsquo;t be a named type defined as a slice literal.&#xA;Writing &lt;code&gt;[S ~[]E, E any]&lt;/code&gt;, with a &lt;code&gt;~&lt;/code&gt;, means that the type argument&#xA;for &lt;code&gt;S&lt;/code&gt; can be any type whose underlying type is a slice type.&lt;/p&gt;&#xA;&lt;p&gt;For any named type &lt;code&gt;type T1 T2&lt;/code&gt; the underlying type of &lt;code&gt;T1&lt;/code&gt; is the&#xA;underlying type of &lt;code&gt;T2&lt;/code&gt;.&#xA;The underlying type of a predeclared type like &lt;code&gt;int&lt;/code&gt; or a type literal&#xA;like &lt;code&gt;[]string&lt;/code&gt; is just the type itself.&#xA;For the exact details, &lt;a href=&#34;https://go.dev/ref/spec#Underlying_types&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;see the language&#xA;spec&lt;/a&gt;.&#xA;In our example, the underlying type of &lt;code&gt;MySlice&lt;/code&gt; is &lt;code&gt;[]string&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Since the underlying type of &lt;code&gt;MySlice&lt;/code&gt; is a slice, we can pass an&#xA;argument of type &lt;code&gt;MySlice&lt;/code&gt; to &lt;code&gt;Clone5&lt;/code&gt;.&#xA;As you may have noticed, the signature of &lt;code&gt;Clone5&lt;/code&gt; is the same as the&#xA;signature of &lt;code&gt;slices.Clone&lt;/code&gt;.&#xA;We&amp;rsquo;ve finally gotten to where we want to be.&lt;/p&gt;&#xA;&lt;p&gt;Before we move on, let&amp;rsquo;s discuss why the Go syntax requires a &lt;code&gt;~&lt;/code&gt;.&#xA;It might seem that we would always want to permit passing &lt;code&gt;MySlice&lt;/code&gt;,&#xA;so why not make that the default?&#xA;Or, if we need to support exact matching, why not flip things around,&#xA;so that a constraint of &lt;code&gt;[]E&lt;/code&gt; permits a named type while a constraint&#xA;of, say, &lt;code&gt;=[]E&lt;/code&gt;, only permits slice type literals?&lt;/p&gt;&#xA;&lt;p&gt;To explain this, let&amp;rsquo;s first observe that a type parameter list like&#xA;&lt;code&gt;[T ~MySlice]&lt;/code&gt; doesn&amp;rsquo;t make sense.&#xA;That&amp;rsquo;s because &lt;code&gt;MySlice&lt;/code&gt; is not the underlying type of any other type.&#xA;For instance, if we have a definition like &lt;code&gt;type MySlice2 MySlice&lt;/code&gt;,&#xA;the underlying type of &lt;code&gt;MySlice2&lt;/code&gt; is &lt;code&gt;[]string&lt;/code&gt;, not &lt;code&gt;MySlice&lt;/code&gt;.&#xA;So either &lt;code&gt;[T ~MySlice]&lt;/code&gt; would permit no types at all, or it would be&#xA;the same as &lt;code&gt;[T MySlice]&lt;/code&gt; and only match &lt;code&gt;MySlice&lt;/code&gt;.&#xA;Either way, &lt;code&gt;[T ~MySlice]&lt;/code&gt; isn&amp;rsquo;t useful.&#xA;To avoid this confusion, the language prohibits &lt;code&gt;[T ~MySlice]&lt;/code&gt;, and&#xA;the compiler produces an error like&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;invalid use of ~ (underlying type of MySlice is []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If Go didn&amp;rsquo;t require the tilde, so that &lt;code&gt;[S []E]&lt;/code&gt; would match any type&#xA;whose underlying type is &lt;code&gt;[]E&lt;/code&gt;, then we would have to define the&#xA;meaning of &lt;code&gt;[S MySlice]&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We could prohibit &lt;code&gt;[S MySlice]&lt;/code&gt;, or we could say that &lt;code&gt;[S MySlice]&lt;/code&gt;&#xA;only matches &lt;code&gt;MySlice&lt;/code&gt;, but either approach runs into trouble with&#xA;predeclared types.&#xA;A predeclared type, like &lt;code&gt;int&lt;/code&gt; is its own underlying type.&#xA;We want to permit people to be able to write constraints that accept&#xA;any type argument whose underlying type is &lt;code&gt;int&lt;/code&gt;.&#xA;In the language today, they can do that by writing &lt;code&gt;[T ~int]&lt;/code&gt;.&#xA;If we don&amp;rsquo;t require the tilde we would still need a way to say &amp;ldquo;any&#xA;type whose underlying type is &lt;code&gt;int&lt;/code&gt;&amp;rdquo;.&#xA;The natural way to say that would be &lt;code&gt;[T int]&lt;/code&gt;.&#xA;That would mean that &lt;code&gt;[T MySlice]&lt;/code&gt; and &lt;code&gt;[T int]&lt;/code&gt; would behave&#xA;differently, although they look very similar.&lt;/p&gt;&#xA;&lt;p&gt;We could perhaps say that &lt;code&gt;[S MySlice]&lt;/code&gt; matches any type whose&#xA;underlying type is the underlying type of &lt;code&gt;MySlice&lt;/code&gt;, but that makes&#xA;&lt;code&gt;[S MySlice]&lt;/code&gt; unnecessary and confusing.&lt;/p&gt;&#xA;&lt;p&gt;We think it&amp;rsquo;s better to require the &lt;code&gt;~&lt;/code&gt; and be very clear about when&#xA;we are matching the underlying type rather than the type itself.&lt;/p&gt;&#xA;&lt;h2 id=&#34;type-inference&#34;&gt;Type inference&lt;/h2&gt;&#xA;&lt;p&gt;Now that we&amp;rsquo;ve explained the signature of &lt;code&gt;slices.Clone&lt;/code&gt;, let&amp;rsquo;s see&#xA;how actually using &lt;code&gt;slices.Clone&lt;/code&gt; is simplified by type inference.&#xA;Remember, the signature of &lt;code&gt;Clone&lt;/code&gt; is&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[S ~[]E, E any](s S) S&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;A call of &lt;code&gt;slices.Clone&lt;/code&gt; will pass a slice to the parameter &lt;code&gt;s&lt;/code&gt;.&#xA;Simple type inference will let the compiler infer that the type&#xA;argument for the type parameter &lt;code&gt;S&lt;/code&gt; is the type of the slice being&#xA;passed to &lt;code&gt;Clone&lt;/code&gt;.&#xA;Type inference is then powerful enough to see that the type argument&#xA;for &lt;code&gt;E&lt;/code&gt; is the element type of the type argument passed to &lt;code&gt;S&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This means that we can write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    c := Clone(ms)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without having to write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    c := Clone[MySlice, string](ms)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If we refer to &lt;code&gt;Clone&lt;/code&gt; without calling it, we do have to specify a&#xA;type argument for &lt;code&gt;S&lt;/code&gt;, as the compiler has nothing it can use to infer&#xA;it.&#xA;Fortunately, in that case, type inference is able to infer the type&#xA;argument for &lt;code&gt;E&lt;/code&gt; from the argument for &lt;code&gt;S&lt;/code&gt;, and we don&amp;rsquo;t have to&#xA;specify it separately.&lt;/p&gt;&#xA;&lt;p&gt;That is, we can write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    myClone := Clone[MySlice]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;without having to write&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;    myClone := Clone[MySlice, string]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;deconstructing-type-parameters&#34;&gt;Deconstructing type parameters&lt;/h2&gt;&#xA;&lt;p&gt;The general technique we&amp;rsquo;ve used here, in which we define one type&#xA;parameter &lt;code&gt;S&lt;/code&gt; using another type parameter &lt;code&gt;E&lt;/code&gt;, is a way to&#xA;deconstruct types in generic function signatures.&#xA;By deconstructing a type, we can name, and constrain, all aspects of&#xA;the type.&lt;/p&gt;&#xA;&lt;p&gt;For example, here is the signature for &lt;code&gt;maps.Clone&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Clone[M ~map[K]V, K comparable, V any](m M) M&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Just as with &lt;code&gt;slices.Clone&lt;/code&gt;, we use a type parameter for the type of&#xA;the parameter &lt;code&gt;m&lt;/code&gt;, and then deconstruct the type using two other type&#xA;parameters &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In &lt;code&gt;maps.Clone&lt;/code&gt; we constrain &lt;code&gt;K&lt;/code&gt; to be comparable, as is required for&#xA;a map key type.&#xA;We can constrain the component types any way we like.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func WithStrings[S ~[]E, E interface { String() string }](s S) (S, []string)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This says that the argument of &lt;code&gt;WithStrings&lt;/code&gt; must be a slice type for&#xA;which the element type has a &lt;code&gt;String&lt;/code&gt; method.&lt;/p&gt;&#xA;&lt;p&gt;Since all Go types can be built up from component types, we can always&#xA;use type parameters to deconstruct those types and constrain them as&#xA;we like.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/type-inference&#34;&gt;Everything You Always Wanted to Know About Type Inference - And a Little Bit More&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/loopvar-preview&#34;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Fixing For Loops in Go 1.22</title><id>tag:blog.golang.org,2013:blog.golang.org/loopvar-preview</id><link rel="alternate" href="https://go.dev/blog/loopvar-preview"></link><published>2023-09-19T00:00:00+00:00</published><updated>2023-09-19T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.21 shipped a preview of a change in Go 1.22 to make for loops less error-prone.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/loopvar-preview&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Fixing For Loops in Go 1.22&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      David Chase and Russ Cox&lt;br&gt;&#xA;      19 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Go 1.21 includes a preview of a change to &lt;code&gt;for&lt;/code&gt; loop scoping&#xA;that we plan to ship in Go 1.22,&#xA;removing one of the most common Go mistakes.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-problem&#34;&gt;The Problem&lt;/h2&gt;&#xA;&lt;p&gt;If you’ve written any amount of Go code, you’ve probably made the mistake&#xA;of keeping a reference to a loop variable past the end of its iteration,&#xA;at which point it takes on a new value that you didn’t want.&#xA;For example, consider this program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    done := make(chan bool)&#xA;&#xA;    values := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}&#xA;    for _, v := range values {&#xA;        go func() {&#xA;            fmt.Println(v)&#xA;            done &amp;lt;- true&#xA;        }()&#xA;    }&#xA;&#xA;    // wait for all goroutines to complete before exiting&#xA;    for _ = range values {&#xA;        &amp;lt;-done&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The three created goroutines are all printing the same variable &lt;code&gt;v&lt;/code&gt;,&#xA;so they usually print “c”, “c”, “c”, instead of printing “a”, “b”, and “c” in some order.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://go.dev/doc/faq#closures_and_goroutines&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Go FAQ entry “What happens with closures running as goroutines?”&lt;/a&gt;,&#xA;gives this example and remarks&#xA;“Some confusion may arise when using closures with concurrency.”&lt;/p&gt;&#xA;&lt;p&gt;Although concurrency is often involved, it need not be.&#xA;This example has the same problem but no goroutines:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func main() {&#xA;    var prints []func()&#xA;    for i := 1; i &amp;lt;= 3; i++ {&#xA;        prints = append(prints, func() { fmt.Println(i) })&#xA;    }&#xA;    for _, print := range prints {&#xA;        print()&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This kind of mistake has caused production problems at many companies,&#xA;including a&#xA;&lt;a href=&#34;https://bugzilla.mozilla.org/show_bug.cgi?id=1619047&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;publicly documented issue at Lets Encrypt&lt;/a&gt;.&#xA;In that instance, the accidental capture of the loop variable was spread across&#xA;multiple functions and much more difficult to notice:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;// authz2ModelMapToPB converts a mapping of domain name to authz2Models into a&#xA;// protobuf authorizations map&#xA;func authz2ModelMapToPB(m map[string]authz2Model) (*sapb.Authorizations, error) {&#xA;    resp := &amp;amp;sapb.Authorizations{}&#xA;    for k, v := range m {&#xA;        // Make a copy of k because it will be reassigned with each loop.&#xA;        kCopy := k&#xA;        authzPB, err := modelToAuthzPB(&amp;amp;v)&#xA;        if err != nil {&#xA;            return nil, err&#xA;        }&#xA;        resp.Authz = append(resp.Authz, &amp;amp;sapb.Authorizations_MapElement{&#xA;            Domain: &amp;amp;kCopy,&#xA;            Authz: authzPB,&#xA;        })&#xA;    }&#xA;    return resp, nil&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The author of this code clearly understood the general problem, because they made a copy of &lt;code&gt;k&lt;/code&gt;,&#xA;but it turns out &lt;code&gt;modelToAuthzPB&lt;/code&gt; used pointers to fields in &lt;code&gt;v&lt;/code&gt; when constructing its result,&#xA;so the loop also needed to make a copy of &lt;code&gt;v&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Tools have been written to identify these mistakes, but it is hard to analyze&#xA;whether references to a variable outlive its iteration or not.&#xA;These tools must choose between false negatives and false positives.&#xA;The &lt;code&gt;loopclosure&lt;/code&gt; analyzer used by &lt;code&gt;go vet&lt;/code&gt; and &lt;code&gt;gopls&lt;/code&gt; opts for false negatives,&#xA;only reporting when it is sure there is a problem but missing others.&#xA;Other checkers opt for false positives, accusing correct code of being incorrect.&#xA;We ran an analysis of commits adding &lt;code&gt;x := x&lt;/code&gt; lines in open-source Go code,&#xA;expecting to find bug fixes.&#xA;Instead we found many unnecessary lines being added,&#xA;suggesting instead that popular checkers have significant false positive rates,&#xA;but developers add the lines anyway to keep the checkers happy.&lt;/p&gt;&#xA;&lt;p&gt;One pair of examples we found was particularly illuminating:&lt;/p&gt;&#xA;&lt;p&gt;This diff was in one program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;     for _, informer := range c.informerMap {&#xA;+        informer := informer&#xA;         go informer.Run(stopCh)&#xA;     }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;And this diff was in another program:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;     for _, a := range alarms {&#xA;+        a := a&#xA;         go a.Monitor(b)&#xA;     }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;One of these two diffs is a bug fix; the other is an unnecessary change.&#xA;You can’t tell which is which unless you know more about the types&#xA;and functions involved.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-fix&#34;&gt;The Fix&lt;/h2&gt;&#xA;&lt;p&gt;For Go 1.22, we plan to change &lt;code&gt;for&lt;/code&gt; loops to make these variables have&#xA;per-iteration scope instead of per-loop scope.&#xA;This change will fix the examples above, so that they are no longer buggy Go programs;&#xA;it will end the production problems caused by such mistakes;&#xA;and it will remove the need for imprecise tools that prompt users&#xA;to make unnecessary changes to their code.&lt;/p&gt;&#xA;&lt;p&gt;To ensure backwards compatibility with existing code, the new semantics&#xA;will only apply in packages contained in modules that declare &lt;code&gt;go 1.22&lt;/code&gt; or&#xA;later in their &lt;code&gt;go.mod&lt;/code&gt; files.&#xA;This per-module decision provides developer control of a gradual update&#xA;to the new semantics throughout a codebase.&#xA;It is also possible to use &lt;code&gt;//go:build&lt;/code&gt; lines to control the decision on a&#xA;per-file basis.&lt;/p&gt;&#xA;&lt;p&gt;Old code will continue to mean exactly what it means today:&#xA;the fix only applies to new or updated code.&#xA;This will give developers control over when the semantics change&#xA;in a particular package.&#xA;As a consequence of our &lt;a href=&#34;toolchain&#34;&gt;forward compatibility work&lt;/a&gt;,&#xA;Go 1.21 will not attempt to compile code that declares &lt;code&gt;go 1.22&lt;/code&gt; or later.&#xA;We included a special case with the same effect in&#xA;the point releases Go 1.20.8 and Go 1.19.13,&#xA;so when Go 1.22 is released,&#xA;code written depending on the new semantics will never be compiled with&#xA;the old semantics, unless people are using very old, &lt;a href=&#34;/doc/devel/release#policy&#34;&gt;unsupported Go versions&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;previewing-the-fix&#34;&gt;Previewing The Fix&lt;/h2&gt;&#xA;&lt;p&gt;Go 1.21 includes a preview of the scoping change.&#xA;If you compile your code with &lt;code&gt;GOEXPERIMENT=loopvar&lt;/code&gt; set in your environment,&#xA;then the new semantics are applied to all loops&#xA;(ignoring the &lt;code&gt;go.mod&lt;/code&gt; &lt;code&gt;go&lt;/code&gt; lines).&#xA;For example, to check whether your tests still pass with the new loop semantics&#xA;applied to your package and all your dependencies:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOEXPERIMENT=loopvar go test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We patched our internal Go toolchain at Google to force this mode during all builds&#xA;at the start of May 2023, and in the past four months&#xA;we have had zero reports of any problems in production code.&lt;/p&gt;&#xA;&lt;p&gt;You can also try test programs to better understand the semantics&#xA;on the Go playground by including a &lt;code&gt;// GOEXPERIMENT=loopvar&lt;/code&gt; comment&#xA;at the top of the program, like in &lt;a href=&#34;https://go.dev/play/p/YchKkkA1ETH&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;this program&lt;/a&gt;.&#xA;(This comment only applies in the Go playground.)&lt;/p&gt;&#xA;&lt;h2 id=&#34;fixing-buggy-tests&#34;&gt;Fixing Buggy Tests&lt;/h2&gt;&#xA;&lt;p&gt;Although we’ve had no production problems,&#xA;to prepare for that switch, we did have to correct many buggy tests that were not&#xA;testing what they thought they were, like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;func TestAllEvenBuggy(t *testing.T) {&#xA;    testCases := []int{1, 2, 4, 6}&#xA;    for _, v := range testCases {&#xA;        t.Run(&amp;quot;sub&amp;quot;, func(t *testing.T) {&#xA;            t.Parallel()&#xA;            if v&amp;amp;1 != 0 {&#xA;                t.Fatal(&amp;quot;odd v&amp;quot;, v)&#xA;            }&#xA;        })&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In Go 1.21, this test passes because &lt;code&gt;t.Parallel&lt;/code&gt; blocks each subtest&#xA;until the entire loop has finished and then runs all the subtests&#xA;in parallel. When the loop has finished, &lt;code&gt;v&lt;/code&gt; is always 6,&#xA;so the subtests all check that 6 is even,&#xA;so the test passes.&#xA;Of course, this test really should fail, because 1 is not even.&#xA;Fixing for loops exposes this kind of buggy test.&lt;/p&gt;&#xA;&lt;p&gt;To help prepare for this kind of discovery, we improved the precision&#xA;of the &lt;code&gt;loopclosure&lt;/code&gt; analyzer in Go 1.21 so that it can identify and&#xA;report this problem.&#xA;You can see the report &lt;a href=&#34;https://go.dev/play/p/WkJkgXRXg0m&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;in this program&lt;/a&gt; on the Go playground.&#xA;If &lt;code&gt;go vet&lt;/code&gt; is reporting this kind of problem in your own tests,&#xA;fixing them will prepare you better for Go 1.22.&lt;/p&gt;&#xA;&lt;p&gt;If you run into other problems,&#xA;&lt;a href=&#34;https://github.com/golang/go/wiki/LoopvarExperiment#my-test-fails-with-the-change-how-can-i-debug-it&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the FAQ&lt;/a&gt;&#xA;has links to examples and details about using a tool we’ve written to identify&#xA;which specific loop is causing a test failure when the new semantics are applied.&lt;/p&gt;&#xA;&lt;h2 id=&#34;more-information&#34;&gt;More Information&lt;/h2&gt;&#xA;&lt;p&gt;For more information about the change, see the&#xA;&lt;a href=&#34;https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;design document&lt;/a&gt;&#xA;and the&#xA;&lt;a href=&#34;https://go.dev/wiki/LoopvarExperiment&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;FAQ&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/deconstructing-type-parameters&#34;&gt;Deconstructing Type Parameters&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/wasi&#34;&gt;WASI support in Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>WASI support in Go</title><id>tag:blog.golang.org,2013:blog.golang.org/wasi</id><link rel="alternate" href="https://go.dev/blog/wasi"></link><published>2023-09-13T00:00:00+00:00</published><updated>2023-09-13T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.21 adds a new port targeting the WASI preview 1 syscall API</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/wasi&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;WASI support in Go&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Johan Brandhorst-Satzkorn, Julien Fabre, Damian Gryski, Evan Phoenix, and Achille Roussel&lt;br&gt;&#xA;      13 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Go 1.21 adds a new port targeting the WASI preview 1 syscall API through the&#xA;new &lt;code&gt;GOOS&lt;/code&gt; value &lt;code&gt;wasip1&lt;/code&gt;. This port builds on the existing WebAssembly&#xA;port introduced in Go 1.11.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-webassembly&#34;&gt;What is WebAssembly?&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://webassembly.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WebAssembly (Wasm)&lt;/a&gt; is a binary instruction format&#xA;originally designed for the web. It represents a standard that allows&#xA;developers to run high-performance, low-level code directly in web browsers at&#xA;near-native speeds.&lt;/p&gt;&#xA;&lt;p&gt;Go first added support for compiling to Wasm in the 1.11 release, through the&#xA;&lt;code&gt;js/wasm&lt;/code&gt; port. This allowed Go code compiled using the Go compiler to be&#xA;executed in web browsers, but it required a JavaScript execution environment.&lt;/p&gt;&#xA;&lt;p&gt;As the use of Wasm has grown, so have use cases outside of the browser. Many&#xA;cloud providers are now offering services that allow the user to execute Wasm&#xA;executables directly, leveraging the new&#xA;&lt;a href=&#34;https://wasi.dev/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WebAssembly System Interface (WASI)&lt;/a&gt; syscall API.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-webassembly-system-interface&#34;&gt;The WebAssembly System Interface&lt;/h2&gt;&#xA;&lt;p&gt;WASI defines a syscall API for Wasm executables, allowing them to interact with&#xA;system resources such as the filesystem, the system clock, random data&#xA;utilities, and more. The latest release of the WASI spec is called&#xA;&lt;code&gt;wasi_snapshot_preview1&lt;/code&gt;, from which we derive the &lt;code&gt;GOOS&lt;/code&gt; name &lt;code&gt;wasip1&lt;/code&gt;. New&#xA;versions of the API are being developed, and supporting them in the Go&#xA;compiler in the future will likely mean adding a new &lt;code&gt;GOOS&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The creation of WASI has allowed a number of Wasm runtimes (hosts) to&#xA;standardize their syscall API around it. Examples of Wasm/WASI hosts include&#xA;&lt;a href=&#34;https://wasmtime.dev&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wasmtime&lt;/a&gt;, &lt;a href=&#34;https://wazero.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wazero&lt;/a&gt;,&#xA;&lt;a href=&#34;https://wasmedge.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;WasmEdge&lt;/a&gt;, &lt;a href=&#34;https://wasmer.io/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Wasmer&lt;/a&gt;, and&#xA;&lt;a href=&#34;https://nodejs.org&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;NodeJS&lt;/a&gt;. There are also a number of cloud providers&#xA;offering hosting of Wasm/WASI executables.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-can-we-use-it-with-go&#34;&gt;How can we use it with Go?&lt;/h2&gt;&#xA;&lt;p&gt;Make sure that you have installed at least version 1.21 of Go. For this demo,&#xA;we’ll use &lt;a href=&#34;https://docs.wasmtime.dev/cli-install.html&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the Wasmtime host&lt;/a&gt; to&#xA;execute our binary. Let’s start with a simple &lt;code&gt;main.go&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main&#xA;&#xA;import &amp;quot;fmt&amp;quot;&#xA;&#xA;func main() {&#xA;    fmt.Println(&amp;quot;Hello world!&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can build it for &lt;code&gt;wasip1&lt;/code&gt; using the command:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ GOOS=wasip1 GOARCH=wasm go build -o main.wasm main.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This will produce a file, &lt;code&gt;main.wasm&lt;/code&gt; which we can execute with &lt;code&gt;wasmtime&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ wasmtime main.wasm&#xA;Hello world!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That’s all it takes to get started with Wasm/WASI! You can expect almost all&#xA;the features of Go to just work with &lt;code&gt;wasip1&lt;/code&gt;. To learn more about the details&#xA;of how WASI works with Go, please see&#xA;&lt;a href=&#34;https://go.dev/issue/58141&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the proposal&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;running-go-tests-with-wasip1&#34;&gt;Running go tests with wasip1&lt;/h2&gt;&#xA;&lt;p&gt;Building and running a binary is easy, but sometimes we want to be able to run&#xA;&lt;code&gt;go test&lt;/code&gt; directly without having to build and execute the binary manually.&#xA;Similar to the &lt;code&gt;js/wasm&lt;/code&gt; port, the standard library distribution included&#xA;in your Go installation comes with a file that makes this very easy. Add the&#xA;&lt;code&gt;misc/wasm&lt;/code&gt; directory to your &lt;code&gt;PATH&lt;/code&gt; when running Go tests and it will&#xA;run the tests using the Wasm host of your choice. This works by &lt;code&gt;go test&lt;/code&gt;&#xA;&lt;a href=&#34;https://pkg.go.dev/cmd/go#hdr-Compile_and_run_Go_program&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;automatically executing&lt;/a&gt;&#xA;&lt;code&gt;misc/wasm/go_wasip1_wasm_exec&lt;/code&gt; when it finds this file in the &lt;code&gt;PATH&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ export PATH=$PATH:$(go env GOROOT)/misc/wasm&#xA;$ GOOS=wasip1 GOARCH=wasm go test ./...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This will run &lt;code&gt;go test&lt;/code&gt; using Wasmtime. The Wasm host used can be controlled&#xA;using the environment variable &lt;code&gt;GOWASIRUNTIME&lt;/code&gt;. Currently supported values&#xA;for this variable are &lt;code&gt;wazero&lt;/code&gt;, &lt;code&gt;wasmedge&lt;/code&gt;, &lt;code&gt;wasmtime&lt;/code&gt;, and &lt;code&gt;wasmer&lt;/code&gt;. This&#xA;script is subject to breaking changes between Go versions. Note that Go&#xA;&lt;code&gt;wasip1&lt;/code&gt; binaries don’t execute perfectly on all hosts yet (see&#xA;&lt;a href=&#34;https://go.dev/issue/59907&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;#59907&lt;/a&gt; and&#xA;&lt;a href=&#34;https://go.dev/issue/60097&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;#60097&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;p&gt;This functionality also works when using &lt;code&gt;go run&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ GOOS=wasip1 GOARCH=wasm go run ./main.go&#xA;Hello world!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;wrapping-wasm-functions-in-go-with-gowasmimport&#34;&gt;Wrapping Wasm functions in Go with go:wasmimport&lt;/h2&gt;&#xA;&lt;p&gt;In addition to the new &lt;code&gt;wasip1/wasm&lt;/code&gt; port, Go 1.21 introduces a new compiler&#xA;directive: &lt;code&gt;go:wasmimport&lt;/code&gt;. It instructs the compiler to translate calls to&#xA;the annotated function into a call to the function specified by the host&#xA;module name and function name. This new compiler functionality is what allowed&#xA;us to define the &lt;code&gt;wasip1&lt;/code&gt; syscall API in Go to support the new port, but it&#xA;isn’t limited to being used in the standard library.&lt;/p&gt;&#xA;&lt;p&gt;For example, the wasip1 syscall API defines the&#xA;&lt;a href=&#34;https://github.com/WebAssembly/WASI/blob/a51a66df5b1db01cf9e873f5537bc5bd552cf770/legacy/preview1/docs.md#-random_getbuf-pointeru8-buf_len-size---result-errno&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;random_get&lt;/code&gt; function&lt;/a&gt;,&#xA;and it is exposed to the Go standard library through&#xA;&lt;a href=&#34;https://cs.opensource.google/go/go/+/refs/tags/go1.21.0:src/runtime/os_wasip1.go;l=73-75&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;a function wrapper&lt;/a&gt;&#xA;defined in the runtime package. It looks like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//go:wasmimport wasi_snapshot_preview1 random_get&#xA;//go:noescape&#xA;func random_get(buf unsafe.Pointer, bufLen size) errno&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This function wrapper is then wrapped in&#xA;&lt;a href=&#34;https://cs.opensource.google/go/go/+/refs/tags/go1.21.0:src/runtime/os_wasip1.go;l=183-187&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;a more ergonomic function&lt;/a&gt;&#xA;for use in the standard library:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getRandomData(r []byte) {&#xA;    if random_get(unsafe.Pointer(&amp;amp;r[0]), size(len(r))) != 0 {&#xA;        throw(&amp;quot;random_get failed&amp;quot;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This way, a user can call &lt;code&gt;getRandomData&lt;/code&gt; with a byte slice and it will&#xA;eventually make its way to the host-defined &lt;code&gt;random_get&lt;/code&gt; function. In the same&#xA;way, users can define their own wrappers for host functions.&lt;/p&gt;&#xA;&lt;p&gt;To learn more about the intricacies of wrapping Wasm functions in Go, please&#xA;see &lt;a href=&#34;https://go.dev/issue/59149&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the &lt;code&gt;go:wasmimport&lt;/code&gt; proposal&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;&#xA;&lt;p&gt;While the &lt;code&gt;wasip1&lt;/code&gt; port passes all standard library tests, there are some&#xA;notable fundamental limitations of the Wasm architecture that may surprise&#xA;users.&lt;/p&gt;&#xA;&lt;p&gt;Wasm is a single threaded architecture with no parallelism. The scheduler can&#xA;still schedule goroutines to run concurrently, and standard in/out/error is&#xA;non-blocking, so a goroutine can execute while another reads or writes, but any&#xA;host function calls (such as requesting random data using the example above)&#xA;will cause all goroutines to block until the host function call has returned.&lt;/p&gt;&#xA;&lt;p&gt;A notable missing feature in the &lt;code&gt;wasip1&lt;/code&gt; API is a full implementation of&#xA;network sockets. &lt;code&gt;wasip1&lt;/code&gt; only defines functions that operate on already opened&#xA;sockets, making it impossible to support some of the most popular features of&#xA;the Go standard library, such as HTTP servers. Hosts like Wasmer and WasmEdge&#xA;implement extensions to the &lt;code&gt;wasip1&lt;/code&gt; API, allowing the opening of network&#xA;sockets. While these extensions are not implemented by the Go compiler, there&#xA;exists a third party library,&#xA;&lt;a href=&#34;https://github.com/stealthrocket/net&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;github.com/stealthrocket/net&lt;/code&gt;&lt;/a&gt;, which&#xA;uses &lt;code&gt;go:wasmimport&lt;/code&gt; to allow the use of &lt;code&gt;net.Dial&lt;/code&gt; and &lt;code&gt;net.Listen&lt;/code&gt; on&#xA;supported Wasm hosts. This enables the creation of &lt;code&gt;net/http&lt;/code&gt; servers and other&#xA;network related functionality when using this package.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-future-of-wasm-in-go&#34;&gt;The future of Wasm in Go&lt;/h2&gt;&#xA;&lt;p&gt;The addition of the &lt;code&gt;wasip1/wasm&lt;/code&gt; port is just the beginning of the Wasm&#xA;capabilities we would like to bring to Go. Please keep an eye out on&#xA;&lt;a href=&#34;https://github.com/golang/go/issues?q=is%3Aopen+is%3Aissue+label%3Aarch-wasm&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the issue tracker&lt;/a&gt;&#xA;for proposals around exporting Go functions to Wasm (&lt;code&gt;go:wasmexport&lt;/code&gt;), a 32-bit&#xA;port and future WASI API compatibility.&lt;/p&gt;&#xA;&lt;h2 id=&#34;get-involved&#34;&gt;Get involved&lt;/h2&gt;&#xA;&lt;p&gt;If you are experimenting with and want to contribute to Wasm and Go, please get&#xA;involved! The Go issue tracker tracks all in-progress work and the #webassembly&#xA;channel on &lt;a href=&#34;https://invite.slack.golangbridge.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the Gophers Slack&lt;/a&gt; is a&#xA;great place to discuss Go and WebAssembly. We look forward to hearing from you!&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/loopvar-preview&#34;&gt;Fixing For Loops in Go 1.22&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/gopls-scalability&#34;&gt;Scaling gopls for the growing Go ecosystem&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Scaling gopls for the growing Go ecosystem</title><id>tag:blog.golang.org,2013:blog.golang.org/gopls-scalability</id><link rel="alternate" href="https://go.dev/blog/gopls-scalability"></link><published>2023-09-08T00:00:00+00:00</published><updated>2023-09-08T00:00:00+00:00</updated><author><name></name></author><summary type="html">As the Go ecosystem gets bigger, gopls must get smaller</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/gopls-scalability&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Scaling gopls for the growing Go ecosystem&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Robert Findley and Alan Donovan&lt;br&gt;&#xA;      8 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;style type=&#34;text/css&#34; scoped&gt;&#xA;  .chart {&#xA;    width: 100%;&#xA;  }&#xA;  @media (prefers-color-scheme: dark) {&#xA;    .chart {&#xA;      border-radius: 8px;&#xA;    }&#xA;  }&#xA;&lt;/style&gt;&#xA;&lt;p&gt;Earlier this summer, the Go team released version &lt;a href=&#34;https://go.dev/s/gopls-v0.12&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;v0.12&lt;/a&gt;&#xA;of &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/gopls&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;gopls&lt;/a&gt;,&#xA;the &lt;a href=&#34;https://microsoft.github.io/language-server-protocol/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;language server&lt;/a&gt; for Go, featuring a rewrite of its core that allows&#xA;it to scale to larger codebases.&#xA;This is the culmination of a year-long effort,&#xA;and we&amp;rsquo;re excited to share our progress, as well as talk a little bit about&#xA;the new architecture and what it means for the future of gopls.&lt;/p&gt;&#xA;&lt;p&gt;Since the v0.12 release, we&amp;rsquo;ve fine-tuned the new design,&#xA;focusing on making interactive queries (such as auto-completion or finding&#xA;references) as fast as they were with v0.11,&#xA;despite holding so much less state in memory.&#xA;If you haven&amp;rsquo;t already, we hope you&amp;rsquo;ll try it out:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/tools/gopls@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We&amp;rsquo;d love to hear about your experience with it via this &lt;a href=&#34;https://google.qualtrics.com/jfe/form/SV_4SnGxpcSKN33WZw?s=blog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;brief survey&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;results&#34;&gt;Reductions in memory use and startup time&lt;/h2&gt;&#xA;&lt;p&gt;Before we dive into the details, let&amp;rsquo;s look at the results!&#xA;The chart below shows the change to startup time and memory usage for 28&#xA;of the most popular Go repositories on GitHub.&#xA;These measurements were taken after opening a randomly selected Go file&#xA;and waiting for gopls to fully load its state,&#xA;and since we assume that the initial indexing is amortized over many editing sessions,&#xA;we take these measurements the &lt;em&gt;second&lt;/em&gt; time we open the file.&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;gopls-scalability/performance-improvements.svg&#34; alt=&#34;Relative savings&#xA;in memory and startup time&#34; class=&#34;chart&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;Across these repos, the savings average around 75%,&#xA;but memory reductions are non-linear:&#xA;as projects get larger, so does the relative decrease in memory usage.&#xA;We&amp;rsquo;ll explain this in more detail below.&lt;/p&gt;&#xA;&lt;h2 id=&#34;background&#34;&gt;Gopls and the evolving Go ecosystem&lt;/h2&gt;&#xA;&lt;p&gt;Gopls provides language-agnostic editors with IDE-like features such as auto-completion,&#xA;formatting, cross-references, and refactoring.&#xA;Since its beginnings in 2018, gopls has consolidated many disparate command-line&#xA;tools such as &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/cmd/guru&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;guru&lt;/a&gt;,&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/cmd/gorename&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;gorename&lt;/a&gt;,&#xA;and &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/cmd/goimports&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;goimports&lt;/a&gt; and&#xA;has become the &lt;a href=&#34;https://go.dev/blog/gopls-vscode-go&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;default backend for the VS Code Go extension&lt;/a&gt;&#xA;as well as many other editors and LSP plugins.&#xA;Perhaps you’ve been using gopls through your editor without even knowing&#xA;it&amp;mdash;that’s the goal!&lt;/p&gt;&#xA;&lt;p&gt;Five years ago, gopls offered improved performance merely by maintaining a stateful session.&#xA;Whereas older command-line tools had to start from scratch each time they executed,&#xA;gopls could save intermediate results to significantly reduce latency.&#xA;But all that state came with a cost, and over time we increasingly &lt;a href=&#34;https://github.com/golang/go/issues?q=is%3Aissue+is%3Aclosed+in%3Atitle+gopls+memory&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;heard from users&lt;/a&gt;&#xA;that gopls&amp;rsquo;s high memory usage was barely tolerable.&lt;/p&gt;&#xA;&lt;p&gt;Meanwhile, the Go ecosystem was growing, with more code being written in&#xA;larger repositories.&#xA;&lt;a href=&#34;https://go.dev/blog/get-familiar-with-workspaces&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Go workspaces&lt;/a&gt; allowed&#xA;developers to work on multiple modules simultaneously,&#xA;and &lt;a href=&#34;https://code.visualstudio.com/docs/devcontainers/containers&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;containerized development&lt;/a&gt;&#xA;put language servers in increasingly resource-constrained environments.&#xA;Codebases were getting larger, and developer environments were getting smaller.&#xA;We needed to change the way gopls scaled in order to keep up.&lt;/p&gt;&#xA;&lt;h2 id=&#34;origins&#34;&gt;Revisiting gopls&amp;rsquo;s compiler origins&lt;/h2&gt;&#xA;&lt;p&gt;In many ways, gopls resembles a compiler:&#xA;it has to read, parse, type-check, and analyze Go source files,&#xA;for which it uses many of the compiler &lt;a href=&#34;https://github.com/golang/example/tree/master/gotypes#introduction&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;building blocks&lt;/a&gt;&#xA;provided by the &lt;a href=&#34;https://pkg.go.dev/go&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Go standard library&lt;/a&gt; and &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;golang.org/x/tools&lt;/a&gt; module.&#xA;These building blocks use the technique of &amp;ldquo;symbolic programming&amp;rdquo;:&#xA;in a running compiler there is a single object or &amp;ldquo;symbol&amp;rdquo; that stands for&#xA;each function such as &lt;code&gt;fmt.Println&lt;/code&gt;.&#xA;Any reference to a function is represented as a pointer to its symbol.&#xA;To test whether two references are talking about the same symbol,&#xA;you don’t need to think about names.&#xA;You just compare pointers. A pointer is much smaller than a string,&#xA;and pointer comparison is very cheap, so symbols are an efficient way to&#xA;represent a structure as complex as a program.&lt;/p&gt;&#xA;&lt;p&gt;In order to respond quickly to requests, gopls v0.11 held all these symbols in memory,&#xA;as though gopls was &lt;strong&gt;compiling your entire program at once&lt;/strong&gt;.&#xA;The result was a memory footprint that was proportional to and much larger&#xA;than the source code being edited (for example,&#xA;typed syntax trees are typically 30x larger than the source text!).&lt;/p&gt;&#xA;&lt;h2 id=&#34;separate-compilation&#34;&gt;Separate compilation&lt;/h2&gt;&#xA;&lt;p&gt;The designers of the first compilers in the 1950s quickly discovered the&#xA;limits of monolithic compilation.&#xA;Their solution was to break the program into units and compile each unit separately.&#xA;Separate compilation makes it possible to build a program that does not fit in memory,&#xA;by doing it in small pieces.&#xA;In Go, the units are packages. Compilation of different packages cannot&#xA;be completely separated:&#xA;when compiling a package P, the compiler still needs information about what&amp;rsquo;s&#xA;provided by the packages that P imports.&#xA;To arrange this, the Go build system compiles all of P&amp;rsquo;s imported packages before P itself,&#xA;and the Go compiler writes a compact summary of each package&amp;rsquo;s exported API.&#xA;The summaries of P&amp;rsquo;s imported packages are provided as inputs to the compilation of P itself.&lt;/p&gt;&#xA;&lt;p&gt;Gopls v0.12 brings separate compilation to gopls,&#xA;reusing the same package summary format used by the compiler.&#xA;The idea is simple, but there’s subtlety in the details.&#xA;We rewrote each algorithm that previously inspected the data structure representing the entire program,&#xA;so that it now works on one package at a time and saves per-package results to files,&#xA;just like a compiler emitting object code.&#xA;For example, finding all references to a function used to be as easy as&#xA;searching the program data structure for all occurrences of a particular pointer value.&#xA;Now, when gopls processes each package, it must construct and save an index&#xA;that associates each identifier location in the source code with the name&#xA;of the symbol to which it refers.&#xA;At query time, gopls loads and searches these indexes.&#xA;Other global queries, such as &amp;ldquo;find implementations&amp;rdquo;,&#xA;use similar techniques.&lt;/p&gt;&#xA;&lt;p&gt;Like the &lt;code&gt;go build&lt;/code&gt; command, gopls now uses a &lt;a href=&#34;https://cs.opensource.google/go/x/tools/+/master:gopls/internal/lsp/filecache/filecache.go;l=5;drc=6f567c8090cb88f13a71b19595bf88c6b27dbeed&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;file-based cache&lt;/a&gt;&#xA;store to record summaries of information computed from each package,&#xA;including the type of each declaration, the index of cross-references,&#xA;and the method set of each type.&#xA;Since the cache is persisted across processes,&#xA;you’ll notice that the second time you start gopls in your workspace,&#xA;it becomes ready to serve much more quickly,&#xA;and if you run two gopls instances, they work together synergistically.&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;gopls-scalability/separate-compilation.png&#34; alt=&#34;separate compilation&#34; class=&#34;chart&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The result of this change is that gopls&amp;rsquo;s memory use is proportional to&#xA;the number of open packages and their direct imports.&#xA;This is why we observe sublinear scaling in the chart above:&#xA;as repositories get larger, the fraction of the project observed by any&#xA;one open package gets smaller.&lt;/p&gt;&#xA;&lt;h2 id=&#34;invalidation&#34;&gt;Fine-grained invalidation&lt;/h2&gt;&#xA;&lt;p&gt;When you make a change in one package, it&amp;rsquo;s only necessary to recompile&#xA;the packages that import that one,&#xA;directly or indirectly.&#xA;This idea is the basis of all incremental build systems since Make in the 1970s,&#xA;and gopls has been using it since its inception.&#xA;In effect, every keystroke in your LSP-enabled editor starts an incremental build!&#xA;However, in a large project, indirect dependencies add up,&#xA;making these incremental rebuilds too slow.&#xA;It turns out that a lot of this work isn&amp;rsquo;t strictly necessary,&#xA;because most changes, such as adding a statement within an existing function,&#xA;don&amp;rsquo;t affect the import summaries.&lt;/p&gt;&#xA;&lt;p&gt;If you make a small change in one file, we have to recompile its package,&#xA;but if the change does not affect the import summary, we don&amp;rsquo;t have to compile any other packages.&#xA;The effect of the change is &amp;ldquo;pruned&amp;rdquo;. A change that does affect the import&#xA;summary requires recompiling the packages that directly import that package,&#xA;but most such changes won&amp;rsquo;t affect the import summaries of &lt;em&gt;those&lt;/em&gt; packages,&#xA;in which case the effect is still pruned and avoids recompiling indirect importers.&#xA;Thanks to this pruning, it is rare for a change in a low-level package to&#xA;require recompiling &lt;em&gt;all&lt;/em&gt; the packages that indirectly depend on that package.&#xA;Pruned incremental rebuilds make the amount of work proportional to the&#xA;scope of each change.&#xA;This is not a new idea: it was introduced by &lt;a href=&#34;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-177.pdf&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Vesta&lt;/a&gt;&#xA;and also used in &lt;a href=&#34;https://go.dev/doc/go1.10#build&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;go build&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The v0.12 release introduces a similar pruning technique to gopls,&#xA;going one step further to implement a faster pruning heuristic based on syntactic analysis.&#xA;By keeping a simplified graph of symbol references in memory,&#xA;gopls can quickly determine whether a change in package &lt;code&gt;c&lt;/code&gt; can possibly&#xA;affect package &lt;code&gt;a&lt;/code&gt; through a chain of references.&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;gopls-scalability/precise-pruning.png&#34; alt=&#34;fine-grained invalidation&#34; class=&#34;chart&#34;/&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;In the example above, there&amp;rsquo;s no chain of references from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;,&#xA;so a is not exposed to changes in c even though it indirectly depends on it.&lt;/p&gt;&#xA;&lt;h2 id=&#34;new-possibilities&#34;&gt;New possibilities&lt;/h2&gt;&#xA;&lt;p&gt;While we&amp;rsquo;re happy with the performance improvements we&amp;rsquo;ve achieved,&#xA;we&amp;rsquo;re also excited about several gopls features that are feasible now that&#xA;gopls is no longer constrained by memory.&lt;/p&gt;&#xA;&lt;p&gt;The first is robust static analysis. Previously,&#xA;our static analysis driver had to operate on gopls&amp;rsquo;s in-memory representation of packages,&#xA;so it couldn&amp;rsquo;t analyze dependencies:&#xA;doing so would pull in too much additional code.&#xA;With that requirement removed, we were able to include a new analysis driver&#xA;in gopls v0.12 that analyzes all dependencies,&#xA;resulting in greater precision.&#xA;For example, gopls now reports diagnostics for &lt;code&gt;Printf&lt;/code&gt; formatting mistakes&#xA;even in your user-defined wrappers around &lt;code&gt;fmt.Printf&lt;/code&gt;.&#xA;Notably, &lt;code&gt;go vet&lt;/code&gt; has provided this level of precision for years,&#xA;but gopls was unable to do this in real time after each edit. Now it can.&lt;/p&gt;&#xA;&lt;p&gt;The second is &lt;a href=&#34;https://go.dev/issue/57979&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;simpler workspace configuration&lt;/a&gt;&#xA;and &lt;a href=&#34;https://go.dev/issue/29202&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;improved handling for build tags&lt;/a&gt;.&#xA;These two features both amount to gopls &amp;ldquo;doing the right thing&amp;rdquo; when you&#xA;open any Go file on your machine,&#xA;but both were infeasible without the optimization work because (for example)&#xA;each build configuration multiplies the memory footprint!&lt;/p&gt;&#xA;&lt;h2 id=&#34;try&#34;&gt;Try it out!&lt;/h2&gt;&#xA;&lt;p&gt;In addition to scalability and performance improvements,&#xA;we&amp;rsquo;ve also fixed &lt;a href=&#34;https://github.com/golang/go/milestone/282?closed=1&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;numerous&lt;/a&gt;&#xA;&lt;a href=&#34;https://github.com/golang/go/milestone/318?closed=1&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;reported bugs&lt;/a&gt; and&#xA;many unreported ones that we discovered while improving test coverage during the transition.&lt;/p&gt;&#xA;&lt;p&gt;To install the latest gopls:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/tools/gopls@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Please try it out and fill out the &lt;a href=&#34;https://google.qualtrics.com/jfe/form/SV_4SnGxpcSKN33WZw?s=blog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;survey&lt;/a&gt; &amp;mdash;&#xA;and if you should encounter a bug,&#xA;&lt;a href=&#34;https://github.com/golang/go/issues/new/choose&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;report it&lt;/a&gt; and we will fix it.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/wasi&#34;&gt;WASI support in Go&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/pgo&#34;&gt;Profile-guided optimization in Go 1.21&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Profile-guided optimization in Go 1.21</title><id>tag:blog.golang.org,2013:blog.golang.org/pgo</id><link rel="alternate" href="https://go.dev/blog/pgo"></link><published>2023-09-05T00:00:00+00:00</published><updated>2023-09-05T00:00:00+00:00</updated><author><name></name></author><summary type="html">Introduction to profile-guided optimization, generally available in Go 1.21.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/pgo&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Profile-guided optimization in Go 1.21&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Michael Pratt&lt;br&gt;&#xA;      5 September 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Earlier in 2023, Go 1.20 &lt;a href=&#34;/blog/pgo-preview&#34;&gt;shipped a preview of profile-guided optimization (PGO)&lt;/a&gt; for users to test.&#xA;After addressing known limitations in the preview, and with additional refinements thanks to community feedback and contributions, PGO support in Go 1.21 is ready for general production use!&#xA;See the &lt;a href=&#34;https://go.dev/doc/pgo&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;profile-guided optimization user guide&lt;/a&gt; for complete documentation.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;#example&#34;&gt;Below&lt;/a&gt; we will run through an example of using PGO to improve the performance of an application.&#xA;Before we get to that, what exactly is &amp;ldquo;profile-guided optimization&amp;rdquo;?&lt;/p&gt;&#xA;&lt;p&gt;When you build a Go binary, the Go compiler performs optimizations to try to generate the best performing binary it can.&#xA;For example, constant propagation can evaluate constant expressions at compile time, avoiding runtime evaluation cost.&#xA;Escape analysis avoids heap allocations for locally-scoped objects, avoiding GC overheads.&#xA;Inlining copies the body of simple functions into callers, often enabling further optimization in the caller (such as additional constant propagation or better escape analysis).&#xA;Devirtualization converts indirect calls on interface values whose type can be determined statically into direct calls to the concrete method (which often enables inlining of the call).&lt;/p&gt;&#xA;&lt;p&gt;Go improves optimizations from release to release, but doing so is no easy task.&#xA;Some optimizations are tunable, but the compiler can’t just &amp;ldquo;turn it up to 11&amp;rdquo; on every optimization because overly aggressive optimizations can actually hurt performance or cause excessive build times.&#xA;Other optimizations require the compiler to make a judgment call about what the &amp;ldquo;common&amp;rdquo; and &amp;ldquo;uncommon&amp;rdquo; paths in a function are.&#xA;The compiler must make a best guess based on static heuristics because it can’t know which cases will be common at run time.&lt;/p&gt;&#xA;&lt;p&gt;Or can it?&lt;/p&gt;&#xA;&lt;p&gt;With no definitive information about how the code is used in a production environment, the compiler can operate only on the source code of packages.&#xA;But we do have a tool to evaluate production behavior: &lt;a href=&#34;https://go.dev/doc/diagnostics#profiling&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;profiling&lt;/a&gt;.&#xA;If we provide a profile to the compiler, it can make more informed decisions: more aggressively optimizing the most frequently used functions, or more accurately selecting common cases.&lt;/p&gt;&#xA;&lt;p&gt;Using profiles of application behavior for compiler optimization is known as &lt;em&gt;Profile-Guided Optimization (PGO)&lt;/em&gt; (also known as Feedback-Directed Optimization (FDO)).&lt;/p&gt;&#xA;&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;&#xA;&lt;p&gt;Let’s build a service that converts Markdown to HTML: users upload Markdown source to &lt;code&gt;/render&lt;/code&gt;, which returns the HTML conversion.&#xA;We can use &lt;a href=&#34;https://pkg.go.dev/gitlab.com/golang-commonmark/markdown&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;gitlab.com/golang-commonmark/markdown&lt;/code&gt;&lt;/a&gt; to implement this easily.&lt;/p&gt;&#xA;&lt;h3 id=&#34;set-up&#34;&gt;Set up&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go mod init example.com/markdown&#xA;$ go get gitlab.com/golang-commonmark/markdown@bf3e522c626a&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;In &lt;code&gt;main.go&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;    &amp;quot;bytes&amp;quot;&#xA;    &amp;quot;io&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;    _ &amp;quot;net/http/pprof&amp;quot;&#xA;&#xA;    &amp;quot;gitlab.com/golang-commonmark/markdown&amp;quot;&#xA;)&#xA;&#xA;func render(w http.ResponseWriter, r *http.Request) {&#xA;    if r.Method != &amp;quot;POST&amp;quot; {&#xA;        http.Error(w, &amp;quot;Only POST allowed&amp;quot;, http.StatusMethodNotAllowed)&#xA;        return&#xA;    }&#xA;&#xA;    src, err := io.ReadAll(r.Body)&#xA;    if err != nil {&#xA;        log.Printf(&amp;quot;error reading body: %v&amp;quot;, err)&#xA;        http.Error(w, &amp;quot;Internal Server Error&amp;quot;, http.StatusInternalServerError)&#xA;        return&#xA;    }&#xA;&#xA;    md := markdown.New(&#xA;        markdown.XHTMLOutput(true),&#xA;        markdown.Typographer(true),&#xA;        markdown.Linkify(true),&#xA;        markdown.Tables(true),&#xA;    )&#xA;&#xA;    var buf bytes.Buffer&#xA;    if err := md.Render(&amp;amp;buf, src); err != nil {&#xA;        log.Printf(&amp;quot;error converting markdown: %v&amp;quot;, err)&#xA;        http.Error(w, &amp;quot;Malformed markdown&amp;quot;, http.StatusBadRequest)&#xA;        return&#xA;    }&#xA;&#xA;    if _, err := io.Copy(w, &amp;amp;buf); err != nil {&#xA;        log.Printf(&amp;quot;error writing response: %v&amp;quot;, err)&#xA;        http.Error(w, &amp;quot;Internal Server Error&amp;quot;, http.StatusInternalServerError)&#xA;        return&#xA;    }&#xA;}&#xA;&#xA;func main() {&#xA;    http.HandleFunc(&amp;quot;/render&amp;quot;, render)&#xA;    log.Printf(&amp;quot;Serving on port 8080...&amp;quot;)&#xA;    log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Build and run the server:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go build -o markdown.nopgo.exe&#xA;$ ./markdown.nopgo.exe&#xA;2023/08/23 03:55:51 Serving on port 8080...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Let’s try sending some Markdown from another terminal.&#xA;We can use the &lt;code&gt;README.md&lt;/code&gt; from the Go project as a sample document:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ curl -o README.md -L &amp;quot;https://raw.githubusercontent.com/golang/go/c16c2c49e2fa98ae551fc6335215fadd62d33542/README.md&amp;quot;&#xA;$ curl --data-binary @README.md http://localhost:8080/render&#xA;&amp;lt;h1&amp;gt;The Go Programming Language&amp;lt;/h1&amp;gt;&#xA;&amp;lt;p&amp;gt;Go is an open source programming language that makes it easy to build simple,&#xA;reliable, and efficient software.&amp;lt;/p&amp;gt;&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;profiling&#34;&gt;Profiling&lt;/h3&gt;&#xA;&lt;p&gt;Now that we have a working service, let’s collect a profile and rebuild with PGO to see if we get better performance.&lt;/p&gt;&#xA;&lt;p&gt;In &lt;code&gt;main.go&lt;/code&gt;, we imported &lt;a href=&#34;https://pkg.go.dev/net/http/pprof&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;net/http/pprof&lt;/a&gt; which automatically adds a &lt;code&gt;/debug/pprof/profile&lt;/code&gt; endpoint to the server for fetching a CPU profile.&lt;/p&gt;&#xA;&lt;p&gt;Normally you want to collect a profile from your production environment so that the compiler gets a representative view of behavior in production.&#xA;Since this example doesn’t have a &amp;ldquo;production&amp;rdquo; environment, I have created a &lt;a href=&#34;https://github.com/prattmic/markdown-pgo/blob/main/load/main.go&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;simple program&lt;/a&gt; to generate load while we collect a profile.&#xA;Fetch and start the load generator (make sure the server is still running!):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go run github.com/prattmic/markdown-pgo/load@latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;While that is running, download a profile from the server:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ curl -o cpu.pprof &amp;quot;http://localhost:8080/debug/pprof/profile?seconds=30&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Once this completes, kill the load generator and the server.&lt;/p&gt;&#xA;&lt;h3 id=&#34;using-the-profile&#34;&gt;Using the profile&lt;/h3&gt;&#xA;&lt;p&gt;The Go toolchain will automatically enable PGO when it finds a profile named &lt;code&gt;default.pgo&lt;/code&gt; in the main package directory.&#xA;Alternatively, the &lt;code&gt;-pgo&lt;/code&gt; flag to &lt;code&gt;go build&lt;/code&gt; takes a path to a profile to use for PGO.&lt;/p&gt;&#xA;&lt;p&gt;We recommend committing &lt;code&gt;default.pgo&lt;/code&gt; files to your repository.&#xA;Storing profiles alongside your source code ensures that users automatically have access to the profile simply by fetching the repository (either via the version control system, or via &lt;code&gt;go get&lt;/code&gt;) and that builds remain reproducible.&lt;/p&gt;&#xA;&lt;p&gt;Let’s build:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ mv cpu.pprof default.pgo&#xA;$ go build -o markdown.withpgo.exe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We can check that PGO was enabled in the build with &lt;code&gt;go version&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go version -m markdown.withpgo.exe&#xA;./markdown.withpgo.exe: go1.21.0&#xA;...&#xA;        build   -pgo=/tmp/pgo121/default.pgo&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;evaluation&#34;&gt;Evaluation&lt;/h3&gt;&#xA;&lt;p&gt;We will use a Go benchmark &lt;a href=&#34;https://github.com/prattmic/markdown-pgo/blob/main/load/bench_test.go&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;version of the load generator&lt;/a&gt; to evaluate the effect of PGO on performance.&lt;/p&gt;&#xA;&lt;p&gt;First, we will benchmark the server without PGO.&#xA;Start that server:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ ./markdown.nopgo.exe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;While that is running, run several benchmark iterations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go get github.com/prattmic/markdown-pgo@latest&#xA;$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=40 -source $(pwd)/README.md &amp;gt; nopgo.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Once that completes, kill the original server and start the version with PGO:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ ./markdown.withpgo.exe&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;While that is running, run several benchmark iterations:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go test github.com/prattmic/markdown-pgo/load -bench=. -count=40 -source $(pwd)/README.md &amp;gt; withpgo.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Once that completes, let’s compare the results:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go install golang.org/x/perf/cmd/benchstat@latest&#xA;$ benchstat nopgo.txt withpgo.txt&#xA;goos: linux&#xA;goarch: amd64&#xA;pkg: github.com/prattmic/markdown-pgo/load&#xA;cpu: Intel(R) Xeon(R) W-2135 CPU @ 3.70GHz&#xA;        │  nopgo.txt  │            withpgo.txt             │&#xA;        │   sec/op    │   sec/op     vs base               │&#xA;Load-12   374.5µ ± 1%   360.2µ ± 0%  -3.83% (p=0.000 n=40)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The new version is around 3.8% faster!&#xA;In Go 1.21, workloads typically get between 2% and 7% CPU usage improvements from enabling PGO.&#xA;Profiles contain a wealth of information about application behavior and Go 1.21 just begins to crack the surface by using this information for a limited set of optimizations.&#xA;Future releases will continue improving performance as more parts of the compiler take advantage of PGO.&lt;/p&gt;&#xA;&lt;h2 id=&#34;next-steps&#34;&gt;Next steps&lt;/h2&gt;&#xA;&lt;p&gt;In this example, after collecting a profile, we rebuilt our server using the exact same source code used in the original build.&#xA;In a real-world scenario, there is always ongoing development.&#xA;So we may collect a profile from production, which is running last week’s code, and use it to build with today’s source code.&#xA;That is perfectly fine!&#xA;PGO in Go can handle minor changes to source code without issue.&#xA;Of course, over time source code will drift more and more, so it is still important to update the profile occasionally.&lt;/p&gt;&#xA;&lt;p&gt;For much more information on using PGO, best practices and caveats to be aware of, please see the &lt;a href=&#34;https://go.dev/doc/pgo&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;profile-guided optimization user guide&lt;/a&gt;.&#xA;If you are curious about what is going on under the hood, keep reading!&lt;/p&gt;&#xA;&lt;h2 id=&#34;under-the-hood&#34;&gt;Under the hood&lt;/h2&gt;&#xA;&lt;p&gt;To get a better understanding of what made this application faster, let’s take a look under the hood to see how performance has changed.&#xA;We are going to take a look at two different PGO-driven optimizations.&lt;/p&gt;&#xA;&lt;h3 id=&#34;inlining&#34;&gt;Inlining&lt;/h3&gt;&#xA;&lt;p&gt;To observe inlining improvements, let’s analyze this markdown application both with and without PGO.&lt;/p&gt;&#xA;&lt;p&gt;I will compare this using a technique called differential profiling, where we collect two profiles (one with PGO and one without) and compare them.&#xA;For differential profiling, it&amp;rsquo;s important that both profiles represent the same amount of &lt;strong&gt;work&lt;/strong&gt;, not the same amount of time, so I&amp;rsquo;ve adjusted the server to automatically collect profiles, and the load generator to send a fixed number of requests and then exit the server.&lt;/p&gt;&#xA;&lt;p&gt;The changes I have made to the server as well as the profiles collected can be found at &lt;a href=&#34;https://github.com/prattmic/markdown-pgo&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;https://github.com/prattmic/markdown-pgo&lt;/a&gt;.&#xA;The load generator was run with &lt;code&gt;-count=300000 -quit&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;As a quick consistency check, let’s take a look at the total CPU time required to handle all 300k requests:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go tool pprof -top cpu.nopgo.pprof | grep &amp;quot;Total samples&amp;quot;&#xA;Duration: 116.92s, Total samples = 118.73s (101.55%)&#xA;$ go tool pprof -top cpu.withpgo.pprof | grep &amp;quot;Total samples&amp;quot;&#xA;Duration: 113.91s, Total samples = 115.03s (100.99%)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;CPU time dropped from ~118s to ~115s, or about 3%.&#xA;This is in line with our benchmark results, which is a good sign that these profiles are representative.&lt;/p&gt;&#xA;&lt;p&gt;Now we can open a differential profile to look for savings:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go tool pprof -diff_base cpu.nopgo.pprof cpu.withpgo.pprof&#xA;File: markdown.profile.withpgo.exe&#xA;Type: cpu&#xA;Time: Aug 28, 2023 at 10:26pm (EDT)&#xA;Duration: 230.82s, Total samples = 118.73s (51.44%)&#xA;Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)&#xA;(pprof) top -cum&#xA;Showing nodes accounting for -0.10s, 0.084% of 118.73s total&#xA;Dropped 268 nodes (cum &amp;lt;= 0.59s)&#xA;Showing top 10 nodes out of 668&#xA;      flat  flat%   sum%        cum   cum%&#xA;    -0.03s 0.025% 0.025%     -2.56s  2.16%  gitlab.com/golang-commonmark/markdown.ruleLinkify&#xA;     0.04s 0.034% 0.0084%     -2.19s  1.84%  net/http.(*conn).serve&#xA;     0.02s 0.017% 0.025%     -1.82s  1.53%  gitlab.com/golang-commonmark/markdown.(*Markdown).Render&#xA;     0.02s 0.017% 0.042%     -1.80s  1.52%  gitlab.com/golang-commonmark/markdown.(*Markdown).Parse&#xA;    -0.03s 0.025% 0.017%     -1.71s  1.44%  runtime.mallocgc&#xA;    -0.07s 0.059% 0.042%     -1.62s  1.36%  net/http.(*ServeMux).ServeHTTP&#xA;     0.04s 0.034% 0.0084%     -1.58s  1.33%  net/http.serverHandler.ServeHTTP&#xA;    -0.01s 0.0084% 0.017%     -1.57s  1.32%  main.render&#xA;     0.01s 0.0084% 0.0084%     -1.56s  1.31%  net/http.HandlerFunc.ServeHTTP&#xA;    -0.09s 0.076% 0.084%     -1.25s  1.05%  runtime.newobject&#xA;(pprof) top&#xA;Showing nodes accounting for -1.41s, 1.19% of 118.73s total&#xA;Dropped 268 nodes (cum &amp;lt;= 0.59s)&#xA;Showing top 10 nodes out of 668&#xA;      flat  flat%   sum%        cum   cum%&#xA;    -0.46s  0.39%  0.39%     -0.91s  0.77%  runtime.scanobject&#xA;    -0.40s  0.34%  0.72%     -0.40s  0.34%  runtime.nextFreeFast (inline)&#xA;     0.36s   0.3%  0.42%      0.36s   0.3%  gitlab.com/golang-commonmark/markdown.performReplacements&#xA;    -0.35s  0.29%  0.72%     -0.37s  0.31%  runtime.writeHeapBits.flush&#xA;     0.32s  0.27%  0.45%      0.67s  0.56%  gitlab.com/golang-commonmark/markdown.ruleReplacements&#xA;    -0.31s  0.26%  0.71%     -0.29s  0.24%  runtime.writeHeapBits.write&#xA;    -0.30s  0.25%  0.96%     -0.37s  0.31%  runtime.deductAssistCredit&#xA;     0.29s  0.24%  0.72%      0.10s 0.084%  gitlab.com/golang-commonmark/markdown.ruleText&#xA;    -0.29s  0.24%  0.96%     -0.29s  0.24%  runtime.(*mspan).base (inline)&#xA;    -0.27s  0.23%  1.19%     -0.42s  0.35%  bytes.(*Buffer).WriteRune&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;When specifying &lt;code&gt;pprof -diff_base&lt;/code&gt;, the values in displayed in pprof are the &lt;em&gt;difference&lt;/em&gt; between the two profiles.&#xA;So, for instance, &lt;code&gt;runtime.scanobject&lt;/code&gt; used 0.46s less CPU time with PGO than without.&#xA;On the other hand, &lt;code&gt;gitlab.com/golang-commonmark/markdown.performReplacements&lt;/code&gt; used 0.36s more CPU time.&#xA;In a differential profile, we typically want to look at the absolute values (&lt;code&gt;flat&lt;/code&gt; and &lt;code&gt;cum&lt;/code&gt; columns), as the percentages aren’t meaningful.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;top -cum&lt;/code&gt; shows the top differences by cumulative change.&#xA;That is, the difference in CPU of a function and all transitive callees from that function.&#xA;This will generally show the outermost frames in our program&amp;rsquo;s call graph, such as &lt;code&gt;main&lt;/code&gt; or another goroutine entry point.&#xA;Here we can see most savings are coming from the &lt;code&gt;ruleLinkify&lt;/code&gt; portion of handling HTTP requests.&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;top&lt;/code&gt; shows the top differences limited only to changes in the function itself.&#xA;This will generally show inner frames in our program&amp;rsquo;s call graph, where most of the actual work is happening.&#xA;Here we can see that individual savings are coming mostly from &lt;code&gt;runtime&lt;/code&gt; functions.&lt;/p&gt;&#xA;&lt;p&gt;What are those? Let’s peek up the call stack to see where they come from:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(pprof) peek scanobject$&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.86s 94.51% |   runtime.gcDrain&#xA;                                            -0.09s  9.89% |   runtime.gcDrainN&#xA;                                             0.04s  4.40% |   runtime.markrootSpans&#xA;    -0.46s  0.39%  0.39%     -0.91s  0.77%                | runtime.scanobject&#xA;                                            -0.19s 20.88% |   runtime.greyobject&#xA;                                            -0.13s 14.29% |   runtime.heapBits.nextFast (inline)&#xA;                                            -0.08s  8.79% |   runtime.heapBits.next&#xA;                                            -0.08s  8.79% |   runtime.spanOfUnchecked (inline)&#xA;                                             0.04s  4.40% |   runtime.heapBitsForAddr&#xA;                                            -0.01s  1.10% |   runtime.findObject&#xA;----------------------------------------------------------+-------------&#xA;(pprof) peek gcDrain$&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                               -1s   100% |   runtime.gcBgMarkWorker.func2&#xA;     0.15s  0.13%  0.13%        -1s  0.84%                | runtime.gcDrain&#xA;                                            -0.86s 86.00% |   runtime.scanobject&#xA;                                            -0.18s 18.00% |   runtime.(*gcWork).balance&#xA;                                            -0.11s 11.00% |   runtime.(*gcWork).tryGet&#xA;                                             0.09s  9.00% |   runtime.pollWork&#xA;                                            -0.03s  3.00% |   runtime.(*gcWork).tryGetFast (inline)&#xA;                                            -0.03s  3.00% |   runtime.markroot&#xA;                                            -0.02s  2.00% |   runtime.wbBufFlush&#xA;                                             0.01s  1.00% |   runtime/internal/atomic.(*Bool).Load (inline)&#xA;                                            -0.01s  1.00% |   runtime.gcFlushBgCredit&#xA;                                            -0.01s  1.00% |   runtime/internal/atomic.(*Int64).Add (inline)&#xA;----------------------------------------------------------+-------------&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;So &lt;code&gt;runtime.scanobject&lt;/code&gt; is ultimately coming from &lt;code&gt;runtime.gcBgMarkWorker&lt;/code&gt;.&#xA;The &lt;a href=&#34;https://go.dev/doc/gc-guide#Identiying_costs&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Go GC Guide&lt;/a&gt; tells us that &lt;code&gt;runtime.gcBgMarkWorker&lt;/code&gt; is part of the garbage collector, so &lt;code&gt;runtime.scanobject&lt;/code&gt; savings must be GC savings.&#xA;What about &lt;code&gt;nextFreeFast&lt;/code&gt; and other &lt;code&gt;runtime&lt;/code&gt; functions?&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(pprof) peek nextFreeFast$&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.40s   100% |   runtime.mallocgc (inline)&#xA;    -0.40s  0.34%  0.34%     -0.40s  0.34%                | runtime.nextFreeFast&#xA;----------------------------------------------------------+-------------&#xA;(pprof) peek writeHeapBits&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.37s   100% |   runtime.heapBitsSetType&#xA;                                                 0     0% |   runtime.(*mspan).initHeapBits&#xA;    -0.35s  0.29%  0.29%     -0.37s  0.31%                | runtime.writeHeapBits.flush&#xA;                                            -0.02s  5.41% |   runtime.arenaIndex (inline)&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.29s   100% |   runtime.heapBitsSetType&#xA;    -0.31s  0.26%  0.56%     -0.29s  0.24%                | runtime.writeHeapBits.write&#xA;                                             0.02s  6.90% |   runtime.arenaIndex (inline)&#xA;----------------------------------------------------------+-------------&#xA;(pprof) peek heapBitsSetType$&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.82s   100% |   runtime.mallocgc&#xA;    -0.12s   0.1%   0.1%     -0.82s  0.69%                | runtime.heapBitsSetType&#xA;                                            -0.37s 45.12% |   runtime.writeHeapBits.flush&#xA;                                            -0.29s 35.37% |   runtime.writeHeapBits.write&#xA;                                            -0.03s  3.66% |   runtime.readUintptr (inline)&#xA;                                            -0.01s  1.22% |   runtime.writeHeapBitsForAddr (inline)&#xA;----------------------------------------------------------+-------------&#xA;(pprof) peek deductAssistCredit$&#xA;Showing nodes accounting for -3.72s, 3.13% of 118.73s total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                            -0.37s   100% |   runtime.mallocgc&#xA;    -0.30s  0.25%  0.25%     -0.37s  0.31%                | runtime.deductAssistCredit&#xA;                                            -0.07s 18.92% |   runtime.gcAssistAlloc&#xA;----------------------------------------------------------+-------------&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Looks like &lt;code&gt;nextFreeFast&lt;/code&gt; and some of the others in the top 10 are ultimately coming from &lt;code&gt;runtime.mallocgc&lt;/code&gt;, which the GC Guide tells us is the memory allocator.&lt;/p&gt;&#xA;&lt;p&gt;Reduced costs in the GC and allocator imply that we are allocating less overall.&#xA;Let’s take a look at the heap profiles for insight:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go tool pprof -sample_index=alloc_objects -diff_base heap.nopgo.pprof heap.withpgo.pprof&#xA;File: markdown.profile.withpgo.exe&#xA;Type: alloc_objects&#xA;Time: Aug 28, 2023 at 10:28pm (EDT)&#xA;Entering interactive mode (type &amp;quot;help&amp;quot; for commands, &amp;quot;o&amp;quot; for options)&#xA;(pprof) top&#xA;Showing nodes accounting for -12044903, 8.29% of 145309950 total&#xA;Dropped 60 nodes (cum &amp;lt;= 726549)&#xA;Showing top 10 nodes out of 58&#xA;      flat  flat%   sum%        cum   cum%&#xA;  -4974135  3.42%  3.42%   -4974135  3.42%  gitlab.com/golang-commonmark/mdurl.Parse&#xA;  -4249044  2.92%  6.35%   -4249044  2.92%  gitlab.com/golang-commonmark/mdurl.(*URL).String&#xA;   -901135  0.62%  6.97%    -977596  0.67%  gitlab.com/golang-commonmark/puny.mapLabels&#xA;   -653998  0.45%  7.42%    -482491  0.33%  gitlab.com/golang-commonmark/markdown.(*StateInline).PushPending&#xA;   -557073  0.38%  7.80%    -557073  0.38%  gitlab.com/golang-commonmark/linkify.Links&#xA;   -557073  0.38%  8.18%    -557073  0.38%  strings.genSplit&#xA;   -436919   0.3%  8.48%    -232152  0.16%  gitlab.com/golang-commonmark/markdown.(*StateBlock).Lines&#xA;   -408617  0.28%  8.77%    -408617  0.28%  net/textproto.readMIMEHeader&#xA;    401432  0.28%  8.49%     499610  0.34%  bytes.(*Buffer).grow&#xA;    291659   0.2%  8.29%     291659   0.2%  bytes.(*Buffer).String (inline)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;-sample_index=alloc_objects&lt;/code&gt; option is showing us the count of allocations, regardless of size.&#xA;This is useful since we are investigating a decrease in CPU usage, which tends to correlate more with allocation count rather than size.&#xA;There are quite a few reductions here, but let’s focus on the biggest reduction, &lt;code&gt;mdurl.Parse&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;For reference, let’s look at the total allocation counts for this function without PGO:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go tool pprof -sample_index=alloc_objects -top heap.nopgo.pprof | grep mdurl.Parse&#xA;   4974135  3.42% 68.60%    4974135  3.42%  gitlab.com/golang-commonmark/mdurl.Parse&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The total count before was 4974135, meaning that &lt;code&gt;mdurl.Parse&lt;/code&gt; has eliminated 100% of allocations!&lt;/p&gt;&#xA;&lt;p&gt;Back in the differential profile, let’s gather a bit more context:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(pprof) peek mdurl.Parse&#xA;Showing nodes accounting for -12257184, 8.44% of 145309950 total&#xA;----------------------------------------------------------+-------------&#xA;      flat  flat%   sum%        cum   cum%   calls calls% + context&#xA;----------------------------------------------------------+-------------&#xA;                                          -2956806 59.44% |   gitlab.com/golang-commonmark/markdown.normalizeLink&#xA;                                          -2017329 40.56% |   gitlab.com/golang-commonmark/markdown.normalizeLinkText&#xA;  -4974135  3.42%  3.42%   -4974135  3.42%                | gitlab.com/golang-commonmark/mdurl.Parse&#xA;----------------------------------------------------------+-------------&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The calls to &lt;code&gt;mdurl.Parse&lt;/code&gt; are coming from &lt;code&gt;markdown.normalizeLink&lt;/code&gt; and &lt;code&gt;markdown.normalizeLinkText&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;(pprof) list mdurl.Parse&#xA;Total: 145309950&#xA;ROUTINE ======================== gitlab.com/golang-commonmark/mdurl.Parse in /usr/local/google/home/mpratt/go/pkg/mod/gitlab.com/golang-commonmark/mdurl@v0.0.0-20191124015652-932350d1cb84/parse&#xA;.go&#xA;  -4974135   -4974135 (flat, cum)  3.42% of Total&#xA;         .          .     60:func Parse(rawurl string) (*URL, error) {&#xA;         .          .     61:   n, err := findScheme(rawurl)&#xA;         .          .     62:   if err != nil {&#xA;         .          .     63:           return nil, err&#xA;         .          .     64:   }&#xA;         .          .     65:&#xA;  -4974135   -4974135     66:   var url URL&#xA;         .          .     67:   rest := rawurl&#xA;         .          .     68:   hostless := false&#xA;         .          .     69:   if n &amp;gt; 0 {&#xA;         .          .     70:           url.RawScheme = rest[:n]&#xA;         .          .     71:           url.Scheme, rest = strings.ToLower(rest[:n]), rest[n+1:]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Full source for these functions and callers can be found at:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://gitlab.com/golang-commonmark/mdurl/-/blob/bd573caec3d827ead19e40b1f141a3802d956710/parse.go#L60&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;mdurl.Parse&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L53&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;markdown.normalizeLink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://gitlab.com/golang-commonmark/markdown/-/blob/fd7971701a0cab12e9347109a4c889f5c0a1a479/util.go#L68&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;markdown.normalizeLinkText&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;So what happened here? In a non-PGO build, &lt;code&gt;mdurl.Parse&lt;/code&gt; is considered too large to be eligible for inlining.&#xA;However, because our PGO profile indicated that the calls to this function were hot, the compiler did inline them.&#xA;We can see this from the &amp;ldquo;(inline)&amp;rdquo; annotation in the profiles:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ go tool pprof -top cpu.nopgo.pprof | grep mdurl.Parse&#xA;     0.36s   0.3% 63.76%      2.75s  2.32%  gitlab.com/golang-commonmark/mdurl.Parse&#xA;$ go tool pprof -top cpu.withpgo.pprof | grep mdurl.Parse&#xA;     0.55s  0.48% 58.12%      2.03s  1.76%  gitlab.com/golang-commonmark/mdurl.Parse (inline)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;mdurl.Parse&lt;/code&gt; creates a &lt;code&gt;URL&lt;/code&gt; as a local variable on line 66 (&lt;code&gt;var url URL&lt;/code&gt;), and then returns a pointer to that variable on line 145 (&lt;code&gt;return &amp;amp;url, nil&lt;/code&gt;).&#xA;Normally this requires the variable to be allocated on the heap, as a reference to it lives beyond function return.&#xA;However, once &lt;code&gt;mdurl.Parse&lt;/code&gt; is inlined into &lt;code&gt;markdown.normalizeLink&lt;/code&gt;, the compiler can observe that the variable does not escape &lt;code&gt;normalizeLink&lt;/code&gt;, which allows the compiler to allocate it on the stack.&#xA;&lt;code&gt;markdown.normalizeLinkText&lt;/code&gt; is similar to &lt;code&gt;markdown.normalizeLink&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The second largest reduction shown in the profile, from &lt;code&gt;mdurl.(*URL).String&lt;/code&gt; is a similar case of eliminating an escape after inlining.&lt;/p&gt;&#xA;&lt;p&gt;In these cases, we got improved performance through fewer heap allocations.&#xA;Part of the power of PGO and compiler optimizations in general is that effects on allocations are not part of the compiler’s PGO implementation at all.&#xA;The only change that PGO made was to allow inlining of these hot function calls.&#xA;All of the effects to escape analysis and heap allocation were standard optimizations that apply to any build.&#xA;Improved escape behavior is a great downstream effect of inlining, but it is not the only effect.&#xA;Many optimizations can take advantage of inlining.&#xA;For example, constant propagation may be able to simplify the code in a function after inlining when some of the inputs are constants.&lt;/p&gt;&#xA;&lt;h3 id=&#34;devirtualization&#34;&gt;Devirtualization&lt;/h3&gt;&#xA;&lt;p&gt;In addition to inling, which we saw in the example above, PGO can also drive conditional devirtualization of interface calls.&lt;/p&gt;&#xA;&lt;p&gt;Before getting to PGO-driven devirtualization, let’s step back and define &amp;ldquo;devirtualization&amp;rdquo; in general.&#xA;Suppose you have code that looks like something like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;f, _ := os.Open(&amp;quot;foo.txt&amp;quot;)&#xA;var r io.Reader = f&#xA;r.Read(b)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Here we have a call to the &lt;code&gt;io.Reader&lt;/code&gt; interface method &lt;code&gt;Read&lt;/code&gt;.&#xA;Since interfaces can have multiple implementations, the compiler generates an &lt;em&gt;indirect&lt;/em&gt; function call, meaning it looks up the correct method to call at run time from the type in the interface value.&#xA;Indirect calls have a small additional runtime cost compared to direct calls, but more importantly they preclude some compiler optimizations.&#xA;For example, the compiler can’t perform escape analysis on an indirect call since it doesn’t know the concrete method implementation.&lt;/p&gt;&#xA;&lt;p&gt;But in the example above, we &lt;em&gt;do&lt;/em&gt; know the concrete method implementation.&#xA;It must be &lt;code&gt;os.(*File).Read&lt;/code&gt;, since &lt;code&gt;*os.File&lt;/code&gt; is the only type that could possibly be assigned to &lt;code&gt;r&lt;/code&gt;.&#xA;In this case, the compiler will perform &lt;em&gt;devirtualization&lt;/em&gt;, where it replaces the indirect call to &lt;code&gt;io.Reader.Read&lt;/code&gt; with a direct call to &lt;code&gt;os.(*File).Read&lt;/code&gt;, thus allowing other optimizations.&lt;/p&gt;&#xA;&lt;p&gt;(You are probably thinking &amp;ldquo;that code is useless, why would anyone write it that way?&amp;rdquo; This is a good point, but note that code like above could be the result of inlining.&#xA;Suppose &lt;code&gt;f&lt;/code&gt; is passed into a function that takes an &lt;code&gt;io.Reader&lt;/code&gt; argument.&#xA;Once the function is inlined, now the &lt;code&gt;io.Reader&lt;/code&gt; becomes concrete.)&lt;/p&gt;&#xA;&lt;p&gt;PGO-driven devirtualization extends this concept to situations where the concrete type is not statically known, but profiling can show that, for example, an &lt;code&gt;io.Reader.Read&lt;/code&gt; call targets &lt;code&gt;os.(*File).Read&lt;/code&gt; most of the time.&#xA;In this case, PGO can replace &lt;code&gt;r.Read(b)&lt;/code&gt; with something like:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;if f, ok := r.(*os.File); ok {&#xA;    f.Read(b)&#xA;} else {&#xA;    r.Read(b)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That is, we add a runtime check for the concrete type that is most likely to appear, and if so use a concrete call, or otherwise fall back to the standard indirect call.&#xA;The advantage here is that the common path (using &lt;code&gt;*os.File&lt;/code&gt;) can be inlined and have additional optimizations applied, but we still maintain a fallback path because a profile is not a guarantee that this will always be the case.&lt;/p&gt;&#xA;&lt;p&gt;In our analysis of the markdown server we didn’t see PGO-driven devirtualization, but we also only looked at the top impacted areas.&#xA;PGO (and most compiler optimizations) generally yield their benefit in the aggregate of very small improvements in lots of different places, so there is likely more happening than just what we looked at.&lt;/p&gt;&#xA;&lt;p&gt;Inlining and devirtualization are the two PGO-driven optimizations available in Go 1.21, but as we’ve seen, these often unlock additional optimizations.&#xA;In addition, future versions of Go will continue to improve PGO with additional optimizations.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/gopls-scalability&#34;&gt;Scaling gopls for the growing Go ecosystem&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Perfectly Reproducible, Verified Go Toolchains</title><id>tag:blog.golang.org,2013:blog.golang.org/rebuild</id><link rel="alternate" href="https://go.dev/blog/rebuild"></link><published>2023-08-28T00:00:00+00:00</published><updated>2023-08-28T00:00:00+00:00</updated><author><name></name></author><summary type="html">Go 1.21 is the first perfectly reproducible Go toolchain.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/rebuild&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Russ Cox&lt;br&gt;&#xA;      28 August 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;One of the key benefits of open-source software is that anyone can read&#xA;the source code and inspect what it does.&#xA;And yet most software, even open-source software,&#xA;is downloaded in the form of compiled binaries,&#xA;which are much more difficult to inspect.&#xA;If an attacker wanted to run a &lt;a href=&#34;https://cloud.google.com/software-supply-chain-security/docs/attack-vectors&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;supply chain attack&lt;/a&gt;&#xA;on an open-source project,&#xA;the least visible way would be to replace the binaries being served while&#xA;leaving the source code unmodified.&lt;/p&gt;&#xA;&lt;p&gt;The best way to address this kind of attack is to make open-source software&#xA;builds &lt;em&gt;reproducible&lt;/em&gt;,&#xA;meaning that a build that starts with the same sources produces the same&#xA;outputs every time it runs.&#xA;That way, anyone can verify that posted binaries are free of hidden changes&#xA;by building from authentic sources and checking that the rebuilt binaries&#xA;are bit-for-bit identical to the posted binaries.&#xA;That approach proves the binaries have no backdoors or other changes not&#xA;present in the source code,&#xA;without having to disassemble or look inside them at all.&#xA;Since anyone can verify the binaries, independent groups can easily detect&#xA;and report supply chain attacks.&lt;/p&gt;&#xA;&lt;p&gt;As supply chain security becomes more important,&#xA;so do reproducible builds, because they provide a simple way to verify the&#xA;posted binaries for open-source projects.&lt;/p&gt;&#xA;&lt;p&gt;Go 1.21.0 is the first Go toolchain with perfectly reproducible builds.&#xA;Earlier toolchains were possible to reproduce,&#xA;but only with significant effort, and probably no one did:&#xA;they just trusted that the binaries posted on &lt;a href=&#34;/dl/&#34;&gt;go.dev/dl&lt;/a&gt; were the correct ones.&#xA;Now it’s easy to “trust but verify.”&lt;/p&gt;&#xA;&lt;p&gt;This post explains what goes into making builds reproducible,&#xA;examines the many changes we had to make to Go to make Go toolchains reproducible,&#xA;and then demonstrates one of the benefits of reproducibility by verifying&#xA;the Ubuntu package for Go 1.21.0.&lt;/p&gt;&#xA;&lt;h2 id=&#34;how&#34;&gt;Making a Build Reproducible&lt;/h2&gt;&#xA;&lt;p&gt;Computers are generally deterministic, so you might think all builds would&#xA;be equally reproducible.&#xA;That’s only true from a certain point of view.&#xA;Let’s call a piece of information a &lt;em&gt;relevant input&lt;/em&gt; when the output of&#xA;a build can change depending on that input.&#xA;A build is reproducible if it can be repeated with all the same relevant inputs.&#xA;Unfortunately, lots of build tools turn out to incorporate inputs that we&#xA;would usually not realize are relevant and that might be difficult to recreate&#xA;or provide as input.&#xA;Let’s call an input an &lt;em&gt;unintentional input&lt;/em&gt; when it turns out to be relevant&#xA;but we didn’t mean it to be.&lt;/p&gt;&#xA;&lt;p&gt;The most common unintentional input in build systems is the current time.&#xA;If a build writes an executable to disk, the file system records the current&#xA;time as the executable’s modification time.&#xA;If the build then packages that file using a tool like “tar” or “zip”,&#xA;the modification time is written into the archive.&#xA;We certainly didn’t want our build to change based on the current time, but it does.&#xA;So the current time turns out to be an unintentional input to the build.&#xA;Worse, most programs don’t let you provide the current time as an input,&#xA;so there is no way to repeat this build.&#xA;To fix this, we might set the time stamps on created files to Unix time&#xA;0 or to a specific time read from one of the build’s source files.&#xA;That way, the current time is no longer a relevant input to the build.&lt;/p&gt;&#xA;&lt;p&gt;Common relevant inputs to a build include:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;the specific version of the source code to build;&lt;/li&gt;&#xA;&lt;li&gt;the specific versions of dependencies that will be included in the build;&lt;/li&gt;&#xA;&lt;li&gt;the operating system running the build, which may affect path names in the resulting binaries;&lt;/li&gt;&#xA;&lt;li&gt;the architecture of the CPU on the build system,&#xA;which may affect which optimizations the compiler uses or the layout of certain data structures;&lt;/li&gt;&#xA;&lt;li&gt;the compiler version being used, as well as compiler options passed to it, which affect how the code is compiled;&lt;/li&gt;&#xA;&lt;li&gt;the name of the directory containing the source code, which may appear in debug information;&lt;/li&gt;&#xA;&lt;li&gt;the user name, group name, uid, and gid of the account running the build, which may appear in file metadata in an archive;&lt;/li&gt;&#xA;&lt;li&gt;and many more.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;To have a reproducible build, every relevant input must be configurable in the build,&#xA;and then the binaries must be posted alongside an explicit configuration&#xA;listing every relevant input.&#xA;If you’ve done that, you have a reproducible build. Congratulations!&lt;/p&gt;&#xA;&lt;p&gt;We’re not done, though. If the binaries can only be reproduced if you&#xA;first find a computer with the right architecture,&#xA;install a specific operating system version,&#xA;compiler version, put the source code in the right directory,&#xA;set your user identity correctly, and so on,&#xA;that may be too much work in practice for anyone to bother.&lt;/p&gt;&#xA;&lt;p&gt;We want builds to be not just reproducible but &lt;em&gt;easy to reproduce&lt;/em&gt;.&#xA;To do that, we need to identify relevant inputs and then,&#xA;instead of documenting them, eliminate them.&#xA;The build obviously has to depend on the source code being built,&#xA;but everything else can be eliminated.&#xA;When a build’s only relevant input is its source code,&#xA;let’s call that &lt;em&gt;perfectly reproducible&lt;/em&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;go&#34;&gt;Perfectly Reproducible Builds for Go&lt;/h2&gt;&#xA;&lt;p&gt;As of Go 1.21, the Go toolchain is perfectly reproducible:&#xA;its only relevant input is the source code for that build.&#xA;We can build a specific toolchain (say, Go for Linux/x86-64) on a Linux/x86-64 host,&#xA;or a Windows/ARM64 host, or a FreeBSD/386 host,&#xA;or any other host that supports Go, and we can use any Go bootstrap compiler,&#xA;including bootstrapping all the way back to Go 1.4’s C implementation,&#xA;and we can vary any other details.&#xA;None of that changes the toolchains that are built.&#xA;If we start with the same toolchain source code,&#xA;we will get the exact same toolchain binaries out.&lt;/p&gt;&#xA;&lt;p&gt;This perfect reproducibility is the culmination of efforts dating back originally to Go 1.10,&#xA;although most of the effort was concentrated in Go 1.20 and Go 1.21.&#xA;This section highlights some of the most interesting relevant inputs that we eliminated.&lt;/p&gt;&#xA;&lt;h3 id=&#34;go110&#34;&gt;Reproducibility in Go 1.10&lt;/h3&gt;&#xA;&lt;p&gt;Go 1.10 introduced a content-aware build cache that decides whether targets&#xA;are up-to-date based on a fingerprint of the build inputs instead of file modification times.&#xA;Because the toolchain itself is one of those build inputs,&#xA;and because Go is written in Go, the &lt;a href=&#34;/s/go15bootstrap&#34;&gt;bootstrap process&lt;/a&gt;&#xA;would only converge if the toolchain build on a single machine was reproducible.&#xA;The overall toolchain build looks like this:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;rebuild/bootstrap.png&#34; srcset=&#34;rebuild/bootstrap.png 1x, rebuild/bootstrap@2x.png 2x&#34; width=&#34;515&#34; height=&#34;177&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;We start by building the sources for the current Go toolchain using an earlier Go version,&#xA;the bootstrap toolchain (Go 1.10 used Go 1.4, written in C;&#xA;Go 1.21 uses Go 1.17).&#xA;That produces “toolchain1”, which we use to build everything again,&#xA;producing “toolchain2”, which we use to build everything again,&#xA;producing “toolchain3”.&lt;/p&gt;&#xA;&lt;p&gt;Toolchain1 and toolchain2 have been built from the same sources but with&#xA;different Go implementations (compilers and libraries),&#xA;so their binaries are certain to be different.&#xA;However, if both Go implementations are non-buggy,&#xA;correct implementations, toolchain1 and toolchain2 should behave exactly the same.&#xA;In particular, when presented with the Go 1.X sources,&#xA;toolchain1’s output (toolchain2) and toolchain2’s output (toolchain3)&#xA;should be identical,&#xA;meaning toolchain2 and toolchain3 should be identical.&lt;/p&gt;&#xA;&lt;p&gt;At least, that’s the idea. Making that true in practice required removing a couple unintentional inputs:&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Randomness.&lt;/strong&gt; Map iteration and running work in multiple goroutines serialized&#xA;with locks both introduce randomness in the order that results may be generated.&#xA;This randomness can make the toolchain produce one of several different&#xA;possible outputs each time it runs.&#xA;To make the build reproducible, we had to find each of these and sort the&#xA;relevant list of items before using it to generate output.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Bootstrap Libraries.&lt;/strong&gt; Any library used by the compiler that can choose&#xA;from multiple different correct outputs might change its output from one&#xA;Go version to the next.&#xA;If that library output change causes a compiler output change,&#xA;then toolchain1 and toolchain2 will not be semantically identical,&#xA;and toolchain2 and toolchain3 will not be bit-for-bit identical.&lt;/p&gt;&#xA;&lt;p&gt;The canonical example is the &lt;a href=&#34;/pkg/sort/&#34;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; package,&#xA;which can place elements that compare equal in &lt;a href=&#34;/blog/compat#output&#34;&gt;any order it likes&lt;/a&gt;.&#xA;A register allocator might sort to prioritize commonly used variables,&#xA;and the linker sorts symbols in the data section by size.&#xA;To completely eliminate any effect from the sorting algorithm,&#xA;the comparison function used must never report two distinct elements as equal.&#xA;In practice, this invariant turned out to be too onerous to impose on every&#xA;use of sort in the toolchain,&#xA;so instead we arranged to copy the Go 1.X &lt;code&gt;sort&lt;/code&gt; package into the source&#xA;tree that is presented to the bootstrap compiler.&#xA;That way, the compiler uses the same sort algorithm when using the bootstrap&#xA;toolchain as it does when built with itself.&lt;/p&gt;&#xA;&lt;p&gt;Another package we had to copy was &lt;a href=&#34;/pkg/compress/zlib/&#34;&gt;&lt;code&gt;compress/zlib&lt;/code&gt;&lt;/a&gt;,&#xA;because the linker writes compressed debug information,&#xA;and optimizations to compression libraries can change the exact output.&#xA;Over time, we’ve &lt;a href=&#34;https://go.googlesource.com/go/+/go1.21.0/src/cmd/dist/buildtool.go#55&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;added other packages to that list too&lt;/a&gt;.&#xA;This approach has the added benefit of allowing the Go 1.X compiler to use&#xA;new APIs added to those packages immediately,&#xA;at the cost that those packages must be written to compile with older versions of Go.&lt;/p&gt;&#xA;&lt;h3 id=&#34;go120&#34;&gt;Reproducibility in Go 1.20&lt;/h3&gt;&#xA;&lt;p&gt;Work on Go 1.20 prepared for both easy reproducible builds and &lt;a href=&#34;toolchain&#34;&gt;toolchain management&lt;/a&gt;&#xA;by removing two more relevant inputs from the toolchain build.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Host C toolchain.&lt;/strong&gt; Some Go packages, most notably &lt;code&gt;net&lt;/code&gt;,&#xA;default to &lt;a href=&#34;cgo&#34;&gt;using &lt;code&gt;cgo&lt;/code&gt;&lt;/a&gt; on most operating systems.&#xA;In some cases, such as macOS and Windows,&#xA;invoking system DLLs using &lt;code&gt;cgo&lt;/code&gt; is the only reliable way to resolve host names.&#xA;When we use &lt;code&gt;cgo&lt;/code&gt;, though, we invoke the host C toolchain (meaning a specific&#xA;C compiler and C library),&#xA;and different toolchains have different compilation algorithms and library code,&#xA;producing different outputs.&#xA;The build graph for a &lt;code&gt;cgo&lt;/code&gt; package looks like:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;rebuild/cgo.png&#34; srcset=&#34;rebuild/cgo.png 1x, rebuild/cgo@2x.png 2x&#34; width=&#34;441&#34; height=&#34;344&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The host C toolchain is therefore a relevant input to the pre-compiled &lt;code&gt;net.a&lt;/code&gt;&#xA;that ships with the toolchain.&#xA;For Go 1.20, we decided to fix this by removing &lt;code&gt;net.a&lt;/code&gt; from the toolchain.&#xA;That is, Go 1.20 stopped shipping pre-compiled packages to seed the build cache with.&#xA;Now, the first time a program uses package &lt;code&gt;net&lt;/code&gt;,&#xA;the Go toolchain compiles it using the local system’s C toolchain and caches that result.&#xA;In addition to removing a relevant input from toolchain builds and making&#xA;toolchain downloads smaller,&#xA;not shipping pre-compiled packages also makes toolchain downloads more portable.&#xA;If we build package &lt;code&gt;net&lt;/code&gt; on one system with one C toolchain and then compile&#xA;other parts of the program on a different system with a different C toolchain,&#xA;in general there is no guarantee that the two parts can be linked together.&lt;/p&gt;&#xA;&lt;p&gt;One reason we shipped the pre-compiled &lt;code&gt;net&lt;/code&gt; package in the first place&#xA;was to allow building programs that used package net even on systems without&#xA;a C toolchain installed.&#xA;If there’s no pre-compiled package, what happens on those systems? The&#xA;answer varies by operating system,&#xA;but in all cases we arranged for the Go toolchain to continue to work well&#xA;for building pure Go programs without a host C toolchain.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;On macOS, we rewrote package net using the underlying mechanisms that cgo would use,&#xA;without any actual C code.&#xA;This avoids invoking the host C toolchain but still emits a binary that&#xA;refers to the required system DLLs.&#xA;This approach is only possible because every Mac has the same dynamic libraries installed.&#xA;Making the non-cgo macOS package net use the system DLLs also meant that&#xA;cross-compiled macOS executables now use the system DLLs for network access,&#xA;resolving a long-standing feature request.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;On Windows, package net already made direct use of DLLs without C code, so nothing needed to be changed.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;On Unix systems, we cannot assume a specific DLL interface to network code,&#xA;but the pure Go version works fine for systems that use typical IP and DNS setups.&#xA;Also, it is much easier to install a C toolchain on Unix systems than it&#xA;is on macOS and especially Windows.&#xA;We changed the &lt;code&gt;go&lt;/code&gt; command to enable or disable &lt;code&gt;cgo&lt;/code&gt; automatically based&#xA;on whether the system has a C toolchain installed.&#xA;Unix systems without a C toolchain fall back to the pure Go version of package net,&#xA;and in the rare cases where that’s not good enough,&#xA;they can install a C toolchain.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Having dropped the pre-compiled packages,&#xA;the only part of the Go toolchain that still depended on the host C toolchain&#xA;was binaries built using package net,&#xA;specifically the &lt;code&gt;go&lt;/code&gt; command.&#xA;With the macOS improvements, it was now viable to build those commands with &lt;code&gt;cgo&lt;/code&gt; disabled,&#xA;completely removing the host C toolchain as an input,&#xA;but we left that final step for Go 1.21.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Host dynamic linker.&lt;/strong&gt; When programs use &lt;code&gt;cgo&lt;/code&gt; on a system using dynamically linked C libraries,&#xA;the resulting binaries contain the path to the system’s dynamic linker,&#xA;something like &lt;code&gt;/lib64/ld-linux-x86-64.so.2&lt;/code&gt;.&#xA;If the path is wrong, the binaries don’t run.&#xA;Typically each operating system/architecture combination has a single correct&#xA;answer for this path.&#xA;Unfortunately, musl-based Linuxes like Alpine Linux use a different dynamic&#xA;linker than glibc-based Linuxes like Ubuntu.&#xA;To make Go run at all on Alpine Linux, in Go bootstrap process looked like this:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;rebuild/linker1.png&#34; srcset=&#34;rebuild/linker1.png 1x, rebuild/linker1@2x.png 2x&#34; width=&#34;480&#34; height=&#34;209&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;The bootstrap program cmd/dist inspected the local system’s dynamic linker&#xA;and wrote that value into a new source file compiled along with the rest&#xA;of the linker sources,&#xA;effectively hard-coding that default into the linker itself.&#xA;Then when the linker built a program from a set of compiled packages,&#xA;it used that default.&#xA;The result is that a Go toolchain built on Alpine is different from a toolchain built on Ubuntu:&#xA;the host configuration is a relevant input to the toolchain build.&#xA;This is a reproducibility problem but also a portability problem:&#xA;a Go toolchain built on Alpine doesn’t build working binaries or even&#xA;run on Ubuntu, and vice versa.&lt;/p&gt;&#xA;&lt;p&gt;For Go 1.20, we took a step toward fixing the reproducibility problem by&#xA;changing the linker to consult the host configuration when it is running,&#xA;instead of having a default hard-coded at toolchain build time:&lt;/p&gt;&#xA;&lt;div class=&#34;image&#34;&gt;&#xA;&lt;img src=&#34;rebuild/linker2.png&#34; srcset=&#34;rebuild/linker2.png 1x, rebuild/linker2@2x.png 2x&#34; width=&#34;450&#34; height=&#34;175&#34;&gt;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;This fixed the portability of the linker binary on Alpine Linux,&#xA;although not the overall toolchain, since the &lt;code&gt;go&lt;/code&gt; command still used package&#xA;&lt;code&gt;net&lt;/code&gt; and therefore &lt;code&gt;cgo&lt;/code&gt; and therefore had a dynamic linker reference in its own binary.&#xA;Just as in the previous section, compiling the &lt;code&gt;go&lt;/code&gt; command without &lt;code&gt;cgo&lt;/code&gt;&#xA;enabled would fix this,&#xA;but we left that change for Go 1.21.&#xA;(We didn’t feel there was enough time left in the Go 1.20 cycle to test&#xA;such that change properly.)&lt;/p&gt;&#xA;&lt;h3 id=&#34;go121&#34;&gt;Reproducibility in Go 1.21&lt;/h3&gt;&#xA;&lt;p&gt;For Go 1.21, the goal of perfect reproducibility was in sight,&#xA;and we took care of the remaining, mostly small,&#xA;relevant inputs that remained.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Host C toolchain and dynamic linker.&lt;/strong&gt; As discussed above,&#xA;Go 1.20 took important steps toward removing the host C toolchain and dynamic&#xA;linker as relevant inputs.&#xA;Go 1.21 completed the removal of these relevant inputs by building the toolchain&#xA;with &lt;code&gt;cgo&lt;/code&gt; disabled.&#xA;This improved portability of the toolchain too:&#xA;Go 1.21 is the first Go release where the standard Go toolchain runs unmodified&#xA;on Alpine Linux systems.&lt;/p&gt;&#xA;&lt;p&gt;Removing these relevant inputs made it possible to cross-compile a Go toolchain&#xA;from a different system without any loss in functionality.&#xA;That in turn improved the supply chain security of the Go toolchain:&#xA;we can now build Go toolchains for all target systems using a trusted Linux/x86-64 system,&#xA;instead of needing to arrange a separate trusted system for each target.&#xA;As a result, Go 1.21 is the first release to include posted binaries for&#xA;all systems at &lt;a href=&#34;/dl/&#34;&gt;go.dev/dl/&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Source directory.&lt;/strong&gt; Go programs include full paths in the runtime and debugging metadata,&#xA;so that when a program crashes or is run in a debugger,&#xA;stack traces include the full path to the source file,&#xA;not just the name of the file in an unspecified directory.&#xA;Unfortunately, including the full path makes the directory where the source&#xA;code is stored a relevant input to the build.&#xA;To fix this, Go 1.21 changed the release toolchain builds to install commands&#xA;like the compiler using &lt;code&gt;go install -trimpath&lt;/code&gt;,&#xA;which replaces the source directory with the module path of the code.&#xA;If a released compiler crashes, the stack trace will print paths like &lt;code&gt;cmd/compile/main.go&lt;/code&gt;&#xA;instead of &lt;code&gt;/home/user/go/src/cmd/compile/main.go&lt;/code&gt;.&#xA;Since the full paths would refer to a directory on a different machine anyway,&#xA;this rewrite is no loss.&#xA;On the other hand, for non-release builds,&#xA;we keep the full path, so that when developers working on the compiler itself cause it to crash,&#xA;IDEs and other tools reading those crashes can easily find the correct source file.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Host operating system.&lt;/strong&gt; Paths on Windows systems are backslash-separated,&#xA;like &lt;code&gt;cmd\\compile\\main.go&lt;/code&gt;.&#xA;Other systems use forward slashes, like &lt;code&gt;cmd/compile/main.go&lt;/code&gt;.&#xA;Although earlier versions of Go had normalized most of these paths to use forward slashes,&#xA;one inconsistency had crept back in, causing slightly different toolchain builds on Windows.&#xA;We found and fixed the bug.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Host architecture.&lt;/strong&gt; Go runs on a variety of ARM systems and can emit&#xA;code using a software library for floating-point math (SWFP) or using hardware&#xA;floating-point instructions (HWFP).&#xA;Toolchains defaulting to one mode or the other will necessarily differ.&#xA;Like we saw with the dynamic linker earlier,&#xA;the Go bootstrap process inspected the build system to make sure that the&#xA;resulting toolchain worked on that system.&#xA;For historical reasons, the rule was “assume SWFP unless the build is&#xA;running on an ARM system with floating-point hardware”,&#xA;with cross-compiled toolchains assuming SWFP.&#xA;The vast majority of ARM systems today do have floating-point hardware,&#xA;so this introduced an unnecessary difference between natively compiled and&#xA;cross-compiled toolchains,&#xA;and as a further wrinkle, Windows ARM builds always assumed HWFP,&#xA;making the decision operating system-dependent.&#xA;We changed the rule to be “assume HWFP unless the build is running on&#xA;an ARM system without floating-point hardware”.&#xA;This way, cross-compilation and builds on modern ARM systems produce identical toolchains.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Packaging logic.&lt;/strong&gt; All the code to create the actual toolchain archives&#xA;we post for download lived in a separate Git repository,&#xA;golang.org/x/build, and the exact details of how archives get packaged does change over time.&#xA;If you wanted to reproduce those archives,&#xA;you needed to have the right version of that repository.&#xA;We removed this relevant input by moving the code to package the archives&#xA;into the main Go source tree, as &lt;code&gt;cmd/distpack&lt;/code&gt;.&#xA;As of Go 1.21, if you have the sources for a given version of Go,&#xA;you also have the sources for packaging the archives.&#xA;The golang.org/x/build repository is no longer a relevant input.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;User IDs.&lt;/strong&gt; The tar archives we posted for download were built from a&#xA;distribution written to the file system,&#xA;and using &lt;a href=&#34;/pkg/archive/tar/#FileInfoHeader&#34;&gt;&lt;code&gt;tar.FileInfoHeader&lt;/code&gt;&lt;/a&gt; copies&#xA;the user and group IDs from the file system into the tar file,&#xA;making the user running the build a relevant input.&#xA;We changed the archiving code to clear these.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Current time.&lt;/strong&gt; Like with user IDs, the tar and zip archives we posted&#xA;for download had been built by copying the file system modification times into the archives,&#xA;making the current time a relevant input.&#xA;We could have cleared the time, but we thought it would look surprising&#xA;and possibly even break some tools to use the Unix or MS-DOS zero time.&#xA;Instead, we changed the go/VERSION file stored in the repository to add&#xA;the time associated with that version:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cat go1.21.0/VERSION&#xA;go1.21.0&#xA;time 2023-08-04T20:14:06Z&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The packagers now copy the time from the VERSION file when writing files to archives,&#xA;instead of copying the local file’s modification times.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Cryptographic signing keys.&lt;/strong&gt; The Go toolchain for macOS won’t run on&#xA;end-user systems unless we sign the binaries with an Apple-approved signing key.&#xA;We use an internal system to get them signed with Google’s signing key,&#xA;and obviously we cannot share that secret key in order to allow others to&#xA;reproduce the signed binaries.&#xA;Instead, we wrote a verifier that can check whether two binaries are identical&#xA;except for their signatures.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;OS-specific packagers.&lt;/strong&gt; We use the Xcode tools &lt;code&gt;pkgbuild&lt;/code&gt; and &lt;code&gt;productbuild&lt;/code&gt;&#xA;to create the downloadable macOS PKG installer,&#xA;and we use WiX to create the downloadable Windows MSI installer.&#xA;We don’t want verifiers to need the same exact versions of those tools,&#xA;so we took the same approach as for the cryptographic signing keys,&#xA;writing a verifier that can look inside the packages and check that the&#xA;toolchain files are exactly as expected.&lt;/p&gt;&#xA;&lt;h2 id=&#34;verify&#34;&gt;Verifying the Go Toolchains&lt;/h2&gt;&#xA;&lt;p&gt;It’s not enough to make Go toolchains reproducible once.&#xA;We want to make sure they stay reproducible,&#xA;and we want to make sure others can reproduce them easily.&lt;/p&gt;&#xA;&lt;p&gt;To keep ourselves honest, we now build all Go distributions on both a trusted&#xA;Linux/x86-64 system and a Windows/x86-64 system.&#xA;Except for the architecture, the two systems have almost nothing in common.&#xA;The two systems must produce bit-for-bit identical archives or else we do&#xA;not proceed with the release.&lt;/p&gt;&#xA;&lt;p&gt;To allow others to verify that we’re honest,&#xA;we’ve written and published a verifier,&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/build/cmd/gorebuild&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;golang.org/x/build/cmd/gorebuild&lt;/code&gt;&lt;/a&gt;.&#xA;That program will start with the source code in our Git repository and rebuild the&#xA;current Go versions, checking that they match the archives posted on &lt;a href=&#34;/dl/&#34;&gt;go.dev/dl&lt;/a&gt;.&#xA;Most archives are required to match bit-for-bit.&#xA;As mentioned above, there are three exceptions where a more relaxed check is used:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The macOS tar.gz file is expected to differ,&#xA;but then the verifier compares the contents inside.&#xA;The rebuilt and posted copies must contain the same files,&#xA;and all the files must match exactly, except for executable binaries.&#xA;Executable binaries must match exactly after stripping code signatures.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The macOS PKG installer is not rebuilt. Instead,&#xA;the verifier reads the files inside the PKG installer and checks that they&#xA;match the macOS tar.gz exactly,&#xA;again after code signature stripping.&#xA;In the long term, the PKG creation is trivial enough that it could potentially&#xA;be added to cmd/distpack,&#xA;but the verifier would still have to parse the PKG file to run the signature-ignoring&#xA;code executable comparison.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The Windows MSI installer is not rebuilt.&#xA;Instead, the verifier invokes the Linux program &lt;code&gt;msiextract&lt;/code&gt; to extract&#xA;the files inside and check that they match the rebuilt Windows zip file exactly.&#xA;In the long term, perhaps the MSI creation could be added to cmd/distpack,&#xA;and then the verifier could use a bit-for-bit MSI comparison.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;We run &lt;code&gt;gorebuild&lt;/code&gt; nightly, posting the results at &lt;a href=&#34;/rebuild&#34;&gt;go.dev/rebuild&lt;/a&gt;,&#xA;and of course anyone else can run it too.&lt;/p&gt;&#xA;&lt;h2 id=&#34;ubuntu&#34;&gt;Verifying Ubuntu’s Go Toolchain&lt;/h2&gt;&#xA;&lt;p&gt;The Go toolchain’s easily reproducible builds should mean that the binaries&#xA;in the toolchains posted on go.dev match the binaries included in other packaging systems,&#xA;even when those packagers build from source.&#xA;Even if the packagers have compiled with different configurations or other changes,&#xA;the easily reproducible builds should still make it easy to reproduce their binaries.&#xA;To demonstrate this, let’s reproduce the Ubuntu &lt;code&gt;golang-1.21&lt;/code&gt; package&#xA;version &lt;code&gt;1.21.0-1&lt;/code&gt; for Linux/x86-64.&lt;/p&gt;&#xA;&lt;p&gt;To start, we need to download and extract the Ubuntu packages,&#xA;which are &lt;a href=&#34;https://linux.die.net/man/1/ar&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;ar(1) archives&lt;/a&gt; containing zstd-compressed tar archives:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ mkdir deb&#xA;$ cd deb&#xA;$ curl -LO http://mirrors.kernel.org/ubuntu/pool/main/g/golang-1.21/golang-1.21-src_1.21.0-1_all.deb&#xA;$ ar xv golang-1.21-src_1.21.0-1_all.deb&#xA;x - debian-binary&#xA;x - control.tar.zst&#xA;x - data.tar.zst&#xA;$ unzstd &amp;lt; data.tar.zst | tar xv&#xA;...&#xA;x ./usr/share/go-1.21/src/archive/tar/common.go&#xA;x ./usr/share/go-1.21/src/archive/tar/example_test.go&#xA;x ./usr/share/go-1.21/src/archive/tar/format.go&#xA;x ./usr/share/go-1.21/src/archive/tar/fuzz_test.go&#xA;...&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That was the source archive. Now the amd64 binary archive:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ rm -f debian-binary *.zst&#xA;$ curl -LO http://mirrors.kernel.org/ubuntu/pool/main/g/golang-1.21/golang-1.21-go_1.21.0-1_amd64.deb&#xA;$ ar xv golang-1.21-src_1.21.0-1_all.deb&#xA;x - debian-binary&#xA;x - control.tar.zst&#xA;x - data.tar.zst&#xA;$ unzstd &amp;lt; data.tar.zst | tar xv | grep -v &#39;/$&#39;&#xA;...&#xA;x ./usr/lib/go-1.21/bin/go&#xA;x ./usr/lib/go-1.21/bin/gofmt&#xA;x ./usr/lib/go-1.21/go.env&#xA;x ./usr/lib/go-1.21/pkg/tool/linux_amd64/addr2line&#xA;x ./usr/lib/go-1.21/pkg/tool/linux_amd64/asm&#xA;x ./usr/lib/go-1.21/pkg/tool/linux_amd64/buildid&#xA;...&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Ubuntu splits the normal Go tree into two halves,&#xA;in /usr/share/go-1.21 and /usr/lib/go-1.21.&#xA;Let’s put them back together:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ mkdir go-ubuntu&#xA;$ cp -R usr/share/go-1.21/* usr/lib/go-1.21/* go-ubuntu&#xA;cp: cannot overwrite directory go-ubuntu/api with non-directory usr/lib/go-1.21/api&#xA;cp: cannot overwrite directory go-ubuntu/misc with non-directory usr/lib/go-1.21/misc&#xA;cp: cannot overwrite directory go-ubuntu/pkg/include with non-directory usr/lib/go-1.21/pkg/include&#xA;cp: cannot overwrite directory go-ubuntu/src with non-directory usr/lib/go-1.21/src&#xA;cp: cannot overwrite directory go-ubuntu/test with non-directory usr/lib/go-1.21/test&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The errors are complaining about copying symlinks, which we can ignore.&lt;/p&gt;&#xA;&lt;p&gt;Now we need to download and extract the upstream Go sources:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ curl -LO https://go.googlesource.com/go/+archive/refs/tags/go1.21.0.tar.gz&#xA;$ mkdir go-clean&#xA;$ cd go-clean&#xA;$ curl -L https://go.googlesource.com/go/+archive/refs/tags/go1.21.0.tar.gz | tar xzv&#xA;...&#xA;x src/archive/tar/common.go&#xA;x src/archive/tar/example_test.go&#xA;x src/archive/tar/format.go&#xA;x src/archive/tar/fuzz_test.go&#xA;...&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;To skip some trial and error, it turns out that Ubuntu builds Go with &lt;code&gt;GO386=softfloat&lt;/code&gt;,&#xA;which forces the use of software floating point when compiling for 32-bit x86,&#xA;and strips (removes symbol tables from) the resulting ELF binaries.&#xA;Let’s start with a &lt;code&gt;GO386=softfloat&lt;/code&gt; build:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cd src&#xA;$ GOOS=linux GO386=softfloat ./make.bash -distpack&#xA;Building Go cmd/dist using /Users/rsc/sdk/go1.17.13. (go1.17.13 darwin/amd64)&#xA;Building Go toolchain1 using /Users/rsc/sdk/go1.17.13.&#xA;Building Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.&#xA;Building Go toolchain2 using go_bootstrap and Go toolchain1.&#xA;Building Go toolchain3 using go_bootstrap and Go toolchain2.&#xA;Building commands for host, darwin/amd64.&#xA;Building packages and commands for target, linux/amd64.&#xA;Packaging archives for linux/amd64.&#xA;distpack: 818d46ede85682dd go1.21.0.src.tar.gz&#xA;distpack: 4fcd8651d084a03d go1.21.0.linux-amd64.tar.gz&#xA;distpack: eab8ed80024f444f v0.0.1-go1.21.0.linux-amd64.zip&#xA;distpack: 58528cce1848ddf4 v0.0.1-go1.21.0.linux-amd64.mod&#xA;distpack: d8da1f27296edea4 v0.0.1-go1.21.0.linux-amd64.info&#xA;---&#xA;Installed Go for linux/amd64 in /Users/rsc/deb/go-clean&#xA;Installed commands in /Users/rsc/deb/go-clean/bin&#xA;*** You need to add /Users/rsc/deb/go-clean/bin to your PATH.&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That left the standard package in &lt;code&gt;pkg/distpack/go1.21.0.linux-amd64.tar.gz&lt;/code&gt;.&#xA;Let’s unpack it and strip the binaries to match Ubuntu:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cd ../..&#xA;$ tar xzvf go-clean/pkg/distpack/go1.21.0.linux-amd64.tar.gz&#xA;x go/CONTRIBUTING.md&#xA;x go/LICENSE&#xA;x go/PATENTS&#xA;x go/README.md&#xA;x go/SECURITY.md&#xA;x go/VERSION&#xA;...&#xA;$ elfstrip go/bin/* go/pkg/tool/linux_amd64/*&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Now we can diff the Go toolchain we’ve created on our Mac with the Go toolchain that Ubuntu ships:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ diff -r go go-ubuntu&#xA;Only in go: CONTRIBUTING.md&#xA;Only in go: LICENSE&#xA;Only in go: PATENTS&#xA;Only in go: README.md&#xA;Only in go: SECURITY.md&#xA;Only in go: codereview.cfg&#xA;Only in go: doc&#xA;Only in go: lib&#xA;Binary files go/misc/chrome/gophertool/gopher.png and go-ubuntu/misc/chrome/gophertool/gopher.png differ&#xA;Only in go-ubuntu/pkg/tool/linux_amd64: dist&#xA;Only in go-ubuntu/pkg/tool/linux_amd64: distpack&#xA;Only in go/src: all.rc&#xA;Only in go/src: clean.rc&#xA;Only in go/src: make.rc&#xA;Only in go/src: run.rc&#xA;diff -r go/src/syscall/mksyscall.pl go-ubuntu/src/syscall/mksyscall.pl&#xA;1c1&#xA;&amp;lt; #!/usr/bin/env perl&#xA;---&#xA;&amp;gt; #! /usr/bin/perl&#xA;...&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;We’ve successfully reproduced the Ubuntu package’s executables and identified&#xA;the complete set of changes that remain:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Various metadata and supporting files have been deleted.&lt;/li&gt;&#xA;&lt;li&gt;The &lt;code&gt;gopher.png&lt;/code&gt; file has been modified. On closer inspection the two are&#xA;identical except for an embedded timestamp that Ubuntu has updated.&#xA;Perhaps Ubuntu’s packaging scripts recompressed the png with a tool that&#xA;rewrites the timestamp even when it cannot improve on the existing compression.&lt;/li&gt;&#xA;&lt;li&gt;The binaries &lt;code&gt;dist&lt;/code&gt; and &lt;code&gt;distpack&lt;/code&gt;, which are built during bootstrap but&#xA;not included in standard archives,&#xA;have been included in the Ubuntu package.&lt;/li&gt;&#xA;&lt;li&gt;The Plan 9 build scripts (&lt;code&gt;*.rc&lt;/code&gt;) have been deleted, although the Windows build scripts (&lt;code&gt;*.bat&lt;/code&gt;) remain.&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;mksyscall.pl&lt;/code&gt; and seven other Perl scripts not shown have had their headers changed.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Note in particular that we’ve reconstructed the toolchain binaries bit-for-bit:&#xA;they do not show up in the diff at all.&#xA;That is, we proved that the Ubuntu Go binaries correspond exactly to the&#xA;upstream Go sources.&lt;/p&gt;&#xA;&lt;p&gt;Even better, we proved this without using any Ubuntu software at all:&#xA;these commands were run on a Mac, and &lt;a href=&#34;https://github.com/rsc/tmp/blob/master/unzstd/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;unzstd&lt;/code&gt;&lt;/a&gt;&#xA;and &lt;a href=&#34;https://github.com/rsc/tmp/blob/master/elfstrip/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;elfstrip&lt;/code&gt;&lt;/a&gt; are short Go programs.&#xA;A sophisticated attacker might insert malicious code into an Ubuntu package&#xA;by changing the package-creation tools.&#xA;If they did, reproducing the Go Ubuntu package from clean sources using&#xA;those malicious tools would still produce bit-for-bit identical copies of&#xA;the malicious packages.&#xA;This attack would be invisible to that kind of rebuild,&#xA;much like &lt;a href=&#34;https://dl.acm.org/doi/10.1145/358198.358210&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Ken Thompson’s compiler attack&lt;/a&gt;.&#xA;Verifying the Ubuntu packages using no Ubuntu software at all is a much&#xA;stronger check.&#xA;Go’s perfectly reproducible builds, which don’t depend on unindented&#xA;details like the host operating system,&#xA;host architecture, and host C toolchain, are what make this stronger check possible.&lt;/p&gt;&#xA;&lt;p&gt;(As an aside for the historical record, Ken Thompson told me once that his&#xA;attack was in fact detected,&#xA;because the compiler build stopped being reproducible.&#xA;It had a bug: a string constant in the backdoor added to the compiler was&#xA;imperfectly handled and grew by a single NUL byte each time the compiler compiled itself.&#xA;Eventually someone noticed the non-reproducible build and tried to find the cause by compiling to assembly.&#xA;The compiler’s backdoor did not reproduce itself into assembly output at all,&#xA;so assembling that output removed the backdoor.)&lt;/p&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&#xA;&lt;p&gt;Reproducible builds are an important tool for strengthening the open-source supply chain.&#xA;Frameworks like &lt;a href=&#34;https://slsa.dev/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;SLSA&lt;/a&gt; focus on provenance and a software&#xA;chain of custody that can be used to inform decisions about trust.&#xA;Reproducible builds complement that approach by providing a way to verify&#xA;that the trust is well-placed.&lt;/p&gt;&#xA;&lt;p&gt;Perfect reproducibility (when the source files are the build’s only relevant&#xA;input) is only possible for programs that build themselves,&#xA;like compiler toolchains.&#xA;It is a lofty but worthwhile goal precisely because self-hosting compiler&#xA;toolchains are otherwise quite difficult to verify.&#xA;Go’s perfect reproducibility means that,&#xA;assuming packagers don’t modify the source code,&#xA;every repackaging of Go 1.21.0 for Linux/x86-64 (substitute your favorite&#xA;system) in any form should be distributing exactly the same binaries,&#xA;even when they all build from source.&#xA;We’ve seen that this is not quite true for Ubuntu Linux,&#xA;but perfect reproducibility still lets us reproduce the Ubuntu packaging&#xA;using a very different, non-Ubuntu system.&lt;/p&gt;&#xA;&lt;p&gt;Ideally all open source software distributed in binary form would have easy-to-reproduce builds.&#xA;In practice, as we’ve seen in this post,&#xA;it is very easy for unintended inputs to leak into builds.&#xA;For Go programs that don’t need &lt;code&gt;cgo&lt;/code&gt;, a reproducible build is as simple&#xA;as compiling with &lt;code&gt;CGO_ENABLED=0 go build -trimpath&lt;/code&gt;.&#xA;Disabling &lt;code&gt;cgo&lt;/code&gt; removes the host C toolchain as a relevant input,&#xA;and &lt;code&gt;-trimpath&lt;/code&gt; removes the current directory.&#xA;If your program does need &lt;code&gt;cgo&lt;/code&gt;, you need to arrange for a specific host&#xA;C toolchain version before running &lt;code&gt;go build&lt;/code&gt;,&#xA;such as by running the build in a specific virtual machine or container image.&lt;/p&gt;&#xA;&lt;p&gt;Moving beyond Go, the &lt;a href=&#34;https://reproducible-builds.org/&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Reproducible Builds&lt;/a&gt;&#xA;project aims to improve reproducibility of all open source and is a good&#xA;starting point for more information about making your own software builds reproducible.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/pgo&#34;&gt;Profile-guided optimization in Go 1.21&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/slog&#34;&gt;Structured Logging with slog&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Structured Logging with slog</title><id>tag:blog.golang.org,2013:blog.golang.org/slog</id><link rel="alternate" href="https://go.dev/blog/slog"></link><published>2023-08-22T00:00:00+00:00</published><updated>2023-08-22T00:00:00+00:00</updated><author><name></name></author><summary type="html">The Go 1.21 standard library includes a new structured logging package, log/slog.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/slog&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Structured Logging with slog&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Jonathan Amsterdam&lt;br&gt;&#xA;      22 August 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;The new &lt;code&gt;log/slog&lt;/code&gt; package in Go 1.21 brings structured logging to the standard&#xA;library. Structured logs use key-value pairs so they can be parsed, filtered,&#xA;searched, and analyzed quickly and reliably.&#xA;For servers, logging is an important way for developers to&#xA;observe the detailed behavior of the system, and often the first place they go&#xA;to debug it. Logs therefore tend to be voluminous, and the ability to search and&#xA;filter them quickly is essential.&lt;/p&gt;&#xA;&lt;p&gt;The standard library has had a logging package, &lt;code&gt;log&lt;/code&gt;,&#xA;since Go&amp;rsquo;s initial release over a decade ago.&#xA;Over time,&#xA;we&amp;rsquo;ve learned that structured logging is important to Go programmers. It has&#xA;consistently ranked high in our annual survey, and many packages in the Go&#xA;ecosystem provide it. Some of these are quite popular: one of the first structured&#xA;logging packages for Go, &lt;a href=&#34;https://pkg.go.dev/github.com/sirupsen/logrus&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;logrus&lt;/a&gt;,&#xA;is used in over 100,000 other packages.&lt;/p&gt;&#xA;&lt;p&gt;With many structured logging packages to choose from, large programs&#xA;will often end up including more than one through their dependencies. The main program&#xA;might have to configure each of these logging packages so that the log output is&#xA;consistent: it all goes to the same place, in the same format. By including&#xA;structured logging in the standard library, we can provide a common framework&#xA;that all the other structured logging packages can share.&lt;/p&gt;&#xA;&lt;h2 id=&#34;a-tour-of-slog&#34;&gt;A tour of &lt;code&gt;slog&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Here is the simplest program that uses &lt;code&gt;slog&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;package main&#xA;&#xA;import &amp;quot;log/slog&amp;quot;&#xA;&#xA;func main() {&#xA;    slog.Info(&amp;quot;hello, world&amp;quot;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;As of this writing, it prints:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;2023/08/04 16:09:19 INFO hello, world&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The &lt;code&gt;Info&lt;/code&gt; function prints a message at the Info log level using the&#xA;default logger, which in this case is the default logger from the &lt;code&gt;log&lt;/code&gt;&#xA;package&amp;mdash;the same logger you get when you write &lt;code&gt;log.Printf&lt;/code&gt;.&#xA;That explains why the output looks so similar: only the &amp;ldquo;INFO&amp;rdquo; is new.&#xA;Out of the box, &lt;code&gt;slog&lt;/code&gt; and the original &lt;code&gt;log&lt;/code&gt; package work together to make it&#xA;easy to get started.&lt;/p&gt;&#xA;&lt;p&gt;Besides &lt;code&gt;Info&lt;/code&gt;, there are functions for three other levels&amp;mdash;&lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Warn&lt;/code&gt;, and&#xA;&lt;code&gt;Error&lt;/code&gt;&amp;mdash;as well as a more general &lt;code&gt;Log&lt;/code&gt; function that takes the level as an&#xA;argument. In &lt;code&gt;slog&lt;/code&gt;, levels are just integers, so you aren&amp;rsquo;t limited to the four&#xA;named levels. For example, &lt;code&gt;Info&lt;/code&gt; is zero and &lt;code&gt;Warn&lt;/code&gt; is 4, so if your logging system&#xA;has a level in between those, you can use 2 for it.&lt;/p&gt;&#xA;&lt;p&gt;Unlike with the &lt;code&gt;log&lt;/code&gt; package, we can easily add key-value pairs to our output&#xA;by writing them after the message:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slog.Info(&amp;quot;hello, world&amp;quot;, &amp;quot;user&amp;quot;, os.Getenv(&amp;quot;USER&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The output now looks like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;2023/08/04 16:27:19 INFO hello, world user=jba&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;As we mentioned, &lt;code&gt;slog&lt;/code&gt;&amp;rsquo;s top-level functions use the default logger.&#xA;We can get this logger explicitly, and call its methods:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;logger := slog.Default()&#xA;logger.Info(&amp;quot;hello, world&amp;quot;, &amp;quot;user&amp;quot;, os.Getenv(&amp;quot;USER&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Every top-level function corresponds to a method on a &lt;code&gt;slog.Logger&lt;/code&gt;.&#xA;The output is the same as before.&lt;/p&gt;&#xA;&lt;p&gt;Initially, slog&amp;rsquo;s output goes through the default &lt;code&gt;log.Logger&lt;/code&gt;, producing the&#xA;output we&amp;rsquo;ve seen above.&#xA;We can change the output by changing the &lt;em&gt;handler&lt;/em&gt; used by the logger.&#xA;&lt;code&gt;slog&lt;/code&gt; comes with two built-in handlers.&#xA;A &lt;code&gt;TextHandler&lt;/code&gt; emits all log information in the form &lt;code&gt;key=value&lt;/code&gt;.&#xA;This program creates a new logger using a &lt;code&gt;TextHandler&lt;/code&gt; and&#xA;makes the same call to the &lt;code&gt;Info&lt;/code&gt; method:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;logger := slog.New(slog.NewTextHandler(os.Stdout, nil))&#xA;logger.Info(&amp;quot;hello, world&amp;quot;, &amp;quot;user&amp;quot;, os.Getenv(&amp;quot;USER&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Now the output looks like this:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;time=2023-08-04T16:56:03.786-04:00 level=INFO msg=&amp;quot;hello, world&amp;quot; user=jba&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Everything has been turned into a key-value pair, with strings quoted as needed to preserve structure.&lt;/p&gt;&#xA;&lt;p&gt;For JSON output, install the built-in &lt;code&gt;JSONHandler&lt;/code&gt; instead:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))&#xA;logger.Info(&amp;quot;hello, world&amp;quot;, &amp;quot;user&amp;quot;, os.Getenv(&amp;quot;USER&amp;quot;))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Now our output is a sequence of JSON objects, one per logging call:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;{&amp;quot;time&amp;quot;:&amp;quot;2023-08-04T16:58:02.939245411-04:00&amp;quot;,&amp;quot;level&amp;quot;:&amp;quot;INFO&amp;quot;,&amp;quot;msg&amp;quot;:&amp;quot;hello, world&amp;quot;,&amp;quot;user&amp;quot;:&amp;quot;jba&amp;quot;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;You are not limited to the built-in handlers. Anyone can write a handler by&#xA;implementing the &lt;code&gt;slog.Handler&lt;/code&gt; interface. A handler can generate output in a&#xA;particular format, or it can wrap another handler to add functionality.&#xA;One of the&#xA;&lt;a href=&#34;https://pkg.go.dev/log/slog@master#example-Handler-LevelHandler&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;examples&lt;/a&gt; in&#xA;the &lt;code&gt;slog&lt;/code&gt; documentation shows how to write a wrapping handler that changes the minimum&#xA;level at which log messages will be displayed.&lt;/p&gt;&#xA;&lt;p&gt;The alternating key-value syntax for attributes that we&amp;rsquo;ve been using so far is convenient, but for frequently executed log statements it may be more efficient to use the &lt;code&gt;Attr&lt;/code&gt; type and call the &lt;code&gt;LogAttrs&lt;/code&gt; method.&#xA;These work together to minimize memory allocations.&#xA;There are functions for building &lt;code&gt;Attr&lt;/code&gt;s out of strings, numbers, and other common&#xA;types. This call to &lt;code&gt;LogAttrs&lt;/code&gt; produces the same output as above, but does it faster:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slog.LogAttrs(context.Background(), slog.LevelInfo, &amp;quot;hello, world&amp;quot;,&#xA;    slog.String(&amp;quot;user&amp;quot;, os.Getenv(&amp;quot;USER&amp;quot;)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;There is a lot more to &lt;code&gt;slog&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;As the call to &lt;code&gt;LogAttrs&lt;/code&gt; shows, you can pass a &lt;code&gt;context.Context&lt;/code&gt; to some log functions&#xA;so a handler can extract context information like trace IDs. (Canceling the context does not prevent the log entry from being written.)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;You can call &lt;code&gt;Logger.With&lt;/code&gt; to add attributes to a logger that will appear in&#xA;all of its output, effectively factoring out the common parts of several log&#xA;statements. This is not only convenient, but it can also help performance, as discussed below.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Attributes can be combined into groups. This can add more structure to your&#xA;log output and can help to disambiguate keys that would otherwise be identical.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;You can control how a value appears in the logs by providing its type with a &lt;code&gt;LogValue&lt;/code&gt;&#xA;method. That can be used to &lt;a href=&#34;https://pkg.go.dev/log/slog@master#example-LogValuer-Group&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;log the fields of a struct as a&#xA;group&lt;/a&gt; or &lt;a href=&#34;https://pkg.go.dev/log/slog@master#example-LogValuer-Secret&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;redact&#xA;sensitive data&lt;/a&gt;,&#xA;among other things.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;The best place to learn about all of &lt;code&gt;slog&lt;/code&gt; is the &lt;a href=&#34;https://pkg.go.dev/log/slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;package&#xA;documentation&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;&#xA;&lt;p&gt;We wanted &lt;code&gt;slog&lt;/code&gt; to be fast.&#xA;For large-scale performance gains, we designed &lt;a href=&#34;https://pkg.go.dev/log/slog#Handler&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;the &lt;code&gt;Handler&lt;/code&gt;&#xA;interface&lt;/a&gt; to provide optimization&#xA;opportunities. The &lt;code&gt;Enabled&lt;/code&gt; method is called at the beginning of every log&#xA;event, giving the handler a chance to drop unwanted log events quickly. The&#xA;&lt;code&gt;WithAttrs&lt;/code&gt; and &lt;code&gt;WithGroup&lt;/code&gt; methods let the handler format&#xA;attributes added by &lt;code&gt;Logger.With&lt;/code&gt; once, rather than at each logging call. This&#xA;pre-formatting can provide a significant speedup when large attributes, like an&#xA;&lt;code&gt;http.Request&lt;/code&gt;, are added to a &lt;code&gt;Logger&lt;/code&gt; and then used in many logging calls.&lt;/p&gt;&#xA;&lt;p&gt;To inform our performance optimization work, we investigated typical patterns of logging in existing open-source projects. We found that over 95%&#xA;of calls to logging methods pass five or fewer attributes. We also categorized&#xA;the types of attributes, finding that a handful of common types accounted for&#xA;the majority.&#xA;We then wrote benchmarks that captured the common cases, and used them as a&#xA;guide to see where the time went.&#xA;The greatest gains came from paying careful attention to memory allocation.&lt;/p&gt;&#xA;&lt;h2 id=&#34;the-design-process&#34;&gt;The design process&lt;/h2&gt;&#xA;&lt;p&gt;The &lt;code&gt;slog&lt;/code&gt; package is one of the largest additions to the standard library since&#xA;Go 1 was released in 2012. We wanted to take our time designing it, and we knew&#xA;that community feedback would be essential.&lt;/p&gt;&#xA;&lt;p&gt;By April 2022, we had gathered enough data to demonstrate the importance of&#xA;structured logging to the Go community. The Go team decided to explore adding it&#xA;to the standard library.&lt;/p&gt;&#xA;&lt;p&gt;We began by looking at how the existing structured logging packages were&#xA;designed. We also took advantage of the large collection of open-source Go code&#xA;stored on the Go module proxy to learn how these packages were actually used.&#xA;Our first design was informed by this research as well as Go&amp;rsquo;s spirit of&#xA;simplicity.&#xA;We wanted an API that is light on the page and easy to understand, without&#xA;sacrificing performance.&lt;/p&gt;&#xA;&lt;p&gt;It was never a goal to replace existing third-party logging packages.&#xA;They are all good at what they do, and replacing existing code that works well&#xA;is rarely a good use of a developer&amp;rsquo;s time.&#xA;We divided the API into a frontend, &lt;code&gt;Logger&lt;/code&gt;, that calls a backend interface, &lt;code&gt;Handler&lt;/code&gt;.&#xA;That way, existing logging packages can talk to a common backend,&#xA;so the packages that use them can interoperate without having to be rewritten.&#xA;Handlers are written or in progress for many common logging&#xA;packages, including&#xA;&lt;a href=&#34;https://github.com/uber-go/zap/tree/master/exp/zapslog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;Zap&lt;/a&gt;,&#xA;&lt;a href=&#34;https://github.com/go-logr/logr/pull/196&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;logr&lt;/a&gt;&#xA;and &lt;a href=&#34;https://github.com/evanphx/go-hclog-slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;hclog&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;We shared our initial design within the Go team and other developers who had&#xA;extensive logging experience. We made alterations based on their feedback, and&#xA;by August of 2022 we felt we had a workable design. On August 29,&#xA;we made our &lt;a href=&#34;https://github.com/golang/exp/tree/master/slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;experimental&#xA;implementation&lt;/a&gt; public&#xA;and began a &lt;a href=&#34;https://github.com/golang/go/discussions/54763&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub discussion&lt;/a&gt; to hear&#xA;what the community had to say.&#xA;The response was enthusiastic and largely positive.&#xA;Thanks to insightful comments from the designers and users of other structured&#xA;logging packages, we made several changes and added a few features, like groups&#xA;and the &lt;code&gt;LogValuer&lt;/code&gt; interface. We changed the mapping from log levels to&#xA;integers twice.&lt;/p&gt;&#xA;&lt;p&gt;After two months and about 300 comments, we felt we were ready for an actual&#xA;&lt;a href=&#34;https://go.dev/issue/56345&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;proposal&lt;/a&gt; and accompanying &lt;a href=&#34;https://go.googlesource.com/proposal/+/03441cb358c7b27a8443bca839e5d7a314677ea6/design/56345-structured-logging.md&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;design&#xA;doc&lt;/a&gt;.&#xA;The proposal issue garnered over 800 comments and resulted in many improvements to&#xA;the API and the implementation. Here are two examples of API changes, both&#xA;concerning &lt;code&gt;context.Context&lt;/code&gt;:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Originally the API supported adding loggers to a&#xA;context. Many felt that this was a convenient way to plumb a logger easily&#xA;through levels of code that didn&amp;rsquo;t care about it. But others felt it was&#xA;smuggling in  an implicit dependency, making the code harder to understand.&#xA;Ultimately, we removed the feature as being too controversial.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;We also wrestled&#xA;with the related question of passing a context to logging methods, trying a&#xA;number of designs. We initially resisted the standard pattern of passing the&#xA;context as the first argument because we didn&amp;rsquo;t want every logging call to&#xA;require a context, but ultimately created two sets of logging methods, one&#xA;with a context and one without.&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;One change we did not make concerned the alternating key-and-value syntax for&#xA;expressing attributes:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slog.Info(&amp;quot;message&amp;quot;, &amp;quot;k1&amp;quot;, v1, &amp;quot;k2&amp;quot;, v2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Many felt strongly that this was a bad idea. They found it hard to read&#xA;and easy to get wrong by omitting a key or value. They preferred explicit&#xA;attributes for expressing structure:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;slog.Info(&amp;quot;message&amp;quot;, slog.Int(&amp;quot;k1&amp;quot;, v1), slog.String(&amp;quot;k2&amp;quot;, v2))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;But we felt that the lighter syntax was important to keeping Go easy and fun to&#xA;use, especially for new Go programmers. We also knew that several Go logging&#xA;packages, like &lt;code&gt;logr&lt;/code&gt;, &lt;code&gt;go-kit/log&lt;/code&gt; and &lt;code&gt;zap&lt;/code&gt; (with its &lt;code&gt;SugaredLogger&lt;/code&gt;)&#xA;successfully used alternating keys and&#xA;values. We added a &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;vet&#xA;check&lt;/a&gt;&#xA;to catch common mistakes, but did not change the design.&lt;/p&gt;&#xA;&lt;p&gt;On March 15, 2023, the proposal was accepted, but there were still some minor&#xA;unresolved issues. Over the next few weeks, ten additional changes were proposed&#xA;and resolved. By early July, the &lt;code&gt;log/slog&lt;/code&gt; package implementation was complete,&#xA;along with the &lt;code&gt;testing/slogtest&lt;/code&gt; package for verifying&#xA;handlers and the vet check for correct usage of alternating keys and values.&lt;/p&gt;&#xA;&lt;p&gt;And on August 8, Go 1.21 was released, and &lt;code&gt;slog&lt;/code&gt; with it.&#xA;We hope you find it useful, and as fun to use as it was to build.&lt;/p&gt;&#xA;&lt;p&gt;And a big thanks to everyone who participated in the discussion and the proposal&#xA;process. Your contributions improved &lt;code&gt;slog&lt;/code&gt; immensely.&lt;/p&gt;&#xA;&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://pkg.go.dev/log/slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;documentation&lt;/a&gt; for the &lt;code&gt;log/slog&lt;/code&gt; package&#xA;explains how to use it and provides several examples.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&#34;https://github.com/golang/go/wiki/Resources-for-slog&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;wiki page&lt;/a&gt; has&#xA;additional resources provided by the Go community, including a variety of&#xA;handlers.&lt;/p&gt;&#xA;&lt;p&gt;If you want to write a handler, consult the&#xA;&lt;a href=&#34;https://github.com/golang/example/blob/master/slog-handler-guide/README.md&#34; rel=&#34;noreferrer&#34; target=&#34;_blank&#34;&gt;handler writing&#xA;guide&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/toolchain&#34;&gt;Forward Compatibility and Toolchain Management in Go 1.21&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry><entry><title>Forward Compatibility and Toolchain Management in Go 1.21</title><id>tag:blog.golang.org,2013:blog.golang.org/toolchain</id><link rel="alternate" href="https://go.dev/blog/toolchain"></link><published>2023-08-14T12:00:01+00:00</published><updated>2023-08-14T12:00:01+00:00</updated><author><name></name></author><summary type="html">Go 1.21 manages Go toolchains like any other dependency; you will never need to manually download and install a Go toolchain again.</summary><content type="html">&#xA;&lt;div id=&#34;blog&#34;&gt;&lt;div id=&#34;content&#34;&gt;&#xA;  &lt;div id=&#34;content&#34;&gt;&#xA;&#xA;    &lt;div class=&#34;Article&#34; data-slug=&#34;/blog/toolchain&#34;&gt;&#xA;    &#xA;    &lt;h1 class=&#34;small&#34;&gt;&lt;a href=&#34;/blog/&#34;&gt;The Go Blog&lt;/a&gt;&lt;/h1&gt;&#xA;    &#xA;&#xA;    &lt;h1&gt;Forward Compatibility and Toolchain Management in Go 1.21&lt;/h1&gt;&#xA;      &#xA;      &lt;p class=&#34;author&#34;&gt;&#xA;      Russ Cox&lt;br&gt;&#xA;      14 August 2023&#xA;      &lt;/p&gt;&#xA;      &#xA;      &lt;p&gt;Beyond Go 1.21&amp;rsquo;s &lt;a href=&#34;compat&#34;&gt;expanded commitment to backward compatibility&lt;/a&gt;,&#xA;Go 1.21 also introduces better forward compatibility for Go code,&#xA;meaning that Go 1.21 and later will take better care not to miscompile&#xA;code that requires an even newer version of Go.&#xA;Specifically, the &lt;code&gt;go&lt;/code&gt; line in &lt;code&gt;go.mod&lt;/code&gt; now specifies a&#xA;minimum required Go toolchain version,&#xA;while in previous releases it was a mostly unenforced suggestion.&lt;/p&gt;&#xA;&lt;p&gt;To make it easier to keep up with these requirements,&#xA;Go 1.21 also introduces toolchain management,&#xA;so that different modules can use different&#xA;Go toolchains just as they can use different&#xA;versions of a required module.&#xA;After installing Go 1.21, you&amp;rsquo;ll never have to manually&#xA;download and install a Go toolchain again.&#xA;The &lt;code&gt;go&lt;/code&gt; command can do it for you.&lt;/p&gt;&#xA;&lt;p&gt;The rest of this post describes both of these Go 1.21 changes in more detail.&lt;/p&gt;&#xA;&lt;h2 id=&#34;forward&#34;&gt;Forward Compatibility&lt;/h2&gt;&#xA;&lt;p&gt;Forward compatibility refers to what happens when a Go toolchain&#xA;attempts to build Go code intended for a newer version of Go.&#xA;If my program depends on a module M and needs a bug&#xA;fix added in M v1.2.3, I can add &lt;code&gt;require M v1.2.3&lt;/code&gt; to my &lt;code&gt;go.mod&lt;/code&gt;,&#xA;guaranteeing that my program won’t be compiled against older versions of M.&#xA;But if my program requires a particular version of Go, there&#xA;hasn’t been any way to express that: in particular, the &lt;code&gt;go.mod&lt;/code&gt; &lt;code&gt;go&lt;/code&gt; line&#xA;did not express that.&lt;/p&gt;&#xA;&lt;p&gt;For example, if I write code that uses the new generics&#xA;added in Go 1.18, I can write &lt;code&gt;go 1.18&lt;/code&gt; in my &lt;code&gt;go.mod&lt;/code&gt; file,&#xA;but that won’t stop earlier versions of Go from trying to compile the code,&#xA;producing errors like:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ cat go.mod&#xA;go 1.18&#xA;module example&#xA;&#xA;$ go version&#xA;go version go1.17&#xA;&#xA;$ go build&#xA;# example&#xA;./x.go:2:6: missing function body&#xA;./x.go:2:7: syntax error: unexpected [, expecting (&#xA;note: module requires Go 1.18&#xA;$&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The two compiler errors are misleading noise.&#xA;The real problem is printed by the &lt;code&gt;go&lt;/code&gt; command as a hint:&#xA;the program failed to compile, so the &lt;code&gt;go&lt;/code&gt; command points&#xA;out the potential version mismatch.&lt;/p&gt;&#xA;&lt;p&gt;In this example, we’re lucky the build failed.&#xA;If I write code that only runs correctly in Go 1.19 or later,&#xA;because it depends on a bug fixed in that patch release,&#xA;but I’m not using any Go 1.19-specific language features&#xA;or packages in the code, earlier versions of Go will compile&#xA;it and silently succeed.&lt;/p&gt;&#xA;&lt;p&gt;Starting in Go 1.21, Go toolchains will treat the &lt;code&gt;go&lt;/code&gt; line in&#xA;&lt;code&gt;go.mod&lt;/code&gt; not as a guideline but as a rule, and the line can&#xA;list specific point releases or release candidates.&#xA;That is, Go 1.21.0 understands that it cannot even build code&#xA;that says &lt;code&gt;go 1.21.1&lt;/code&gt; in its &lt;code&gt;go.mod&lt;/code&gt; file,&#xA;not to mention code that says much later versions like &lt;code&gt;go 1.22.0&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The main reason we allowed older versions of Go to try to&#xA;compile newer code was to avoid unnecessary build failures.&#xA;It’s very frustrating to be told that your version of Go is too&#xA;old to build a program, especially if it might work anyway&#xA;(maybe the requirement is unnecessarily conservative),&#xA;and especially when updating to a newer Go version is a bit&#xA;of a chore.&#xA;To reduce the impact of enforcing the &lt;code&gt;go&lt;/code&gt; line as a requirement,&#xA;Go 1.21 adds toolchain management to the core distribution as well.&lt;/p&gt;&#xA;&lt;h2 id=&#34;toolchain-management&#34;&gt;Toolchain Management&lt;/h2&gt;&#xA;&lt;p&gt;When you need a new version of a Go module, the &lt;code&gt;go&lt;/code&gt; command&#xA;downloads it for you.&#xA;Starting in Go 1.21, when you need a newer Go toolchain,&#xA;the &lt;code&gt;go&lt;/code&gt; command downloads that for you too.&#xA;This functionality is like Node’s &lt;code&gt;nvm&lt;/code&gt; or Rust’s &lt;code&gt;rustup&lt;/code&gt;, but built in to&#xA;the core &lt;code&gt;go&lt;/code&gt; command instead of being a separate tool.&lt;/p&gt;&#xA;&lt;p&gt;If you are running Go 1.21.0 and you run a &lt;code&gt;go&lt;/code&gt; command, say, &lt;code&gt;go build&lt;/code&gt;,&#xA;in a module with a &lt;code&gt;go.mod&lt;/code&gt; that says &lt;code&gt;go 1.21.1&lt;/code&gt;,&#xA;the Go 1.21.0 &lt;code&gt;go&lt;/code&gt; command will notice that you need Go 1.21.1,&#xA;download it, and re-invoke that version’s &lt;code&gt;go&lt;/code&gt; command to finish the build.&#xA;When the &lt;code&gt;go&lt;/code&gt; command downloads and runs these other toolchains,&#xA;it doesn’t install them in your PATH or overwrite the current installation.&#xA;Instead, it downloads them as Go modules, inheriting all the&#xA;&lt;a href=&#34;/blog/module-mirror-launch&#34;&gt;security and privacy benefits of modules&lt;/a&gt;,&#xA;and then it runs them from the module cache.&lt;/p&gt;&#xA;&lt;p&gt;There is also a new &lt;code&gt;toolchain&lt;/code&gt; line in &lt;code&gt;go.mod&lt;/code&gt; that specifies the&#xA;minimum Go toolchain to use when working in a particular module.&#xA;In contrast to the &lt;code&gt;go&lt;/code&gt; line, &lt;code&gt;toolchain&lt;/code&gt; does not impose a requirement&#xA;on other modules.&#xA;For example, a &lt;code&gt;go.mod&lt;/code&gt; might say:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;module m&#xA;go 1.21.0&#xA;toolchain go1.21.4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;This says that other modules requiring &lt;code&gt;m&lt;/code&gt; need to provide at least Go 1.21.0,&#xA;but when we are working in &lt;code&gt;m&lt;/code&gt; itself, we want an even newer toolchain,&#xA;at least Go 1.21.4.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;code&gt;go&lt;/code&gt; and &lt;code&gt;toolchain&lt;/code&gt; requirements can be updated using &lt;code&gt;go get&lt;/code&gt;&#xA;like ordinary module requirements. For example, if you’re using one&#xA;of the Go 1.21 release candidates, you can start using Go 1.21.0&#xA;in a particular module by running:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go get go@1.21.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;That will download and run Go 1.21.0 to update the &lt;code&gt;go&lt;/code&gt; line,&#xA;and future invocations of the &lt;code&gt;go&lt;/code&gt; command will see the line&#xA;&lt;code&gt;go 1.21.0&lt;/code&gt; and automatically re-invoke that version.&lt;/p&gt;&#xA;&lt;p&gt;Or if you want to start using Go 1.21.0 in a module but leave&#xA;the &lt;code&gt;go&lt;/code&gt; line set to an older version, to help maintain compatibility with&#xA;users of earlier versions of Go, you can update the &lt;code&gt;toolchain&lt;/code&gt; line:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go get toolchain@go1.21.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;If you’re ever wondering which Go version is running in a particular&#xA;module, the answer is the same as before: run &lt;code&gt;go version&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;You can force the use of a specific Go toolchain version using&#xA;the GOTOOLCHAIN environment variable.&#xA;For example, to test code with Go 1.20.4:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GOTOOLCHAIN=go1.20.4 go test&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Finally, a GOTOOLCHAIN setting of the form &lt;code&gt;version+auto&lt;/code&gt; means to&#xA;use &lt;code&gt;version&lt;/code&gt; by default but allow upgrades to newer versions as well.&#xA;If you have Go 1.21.0 installed, then when Go 1.21.1 is released,&#xA;you can change your system default by setting a default GOTOOLCHAIN:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;go env -w GOTOOLCHAIN=go1.21.1+auto&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;You&amp;rsquo;ll never have to manually download and install a Go toolchain again.&#xA;The &lt;code&gt;go&lt;/code&gt; command will take care of it for you.&lt;/p&gt;&#xA;&lt;p&gt;See “&lt;a href=&#34;/doc/toolchain&#34;&gt;Go Toolchains&lt;/a&gt;” for more details.&lt;/p&gt;&#xA;&#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;Article prevnext&#34;&gt;&#xA;    &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;        &lt;p&gt;&#xA;        &#xA;          &#xA;            &lt;b&gt;Next article: &lt;/b&gt;&lt;a href=&#34;/blog/slog&#34;&gt;Structured Logging with slog&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &#xA;          &#xA;            &lt;b&gt;Previous article: &lt;/b&gt;&lt;a href=&#34;/blog/compat&#34;&gt;Backward Compatibility, Go 1.21, and Go 2&lt;/a&gt;&lt;br&gt;&#xA;          &#xA;        &#xA;        &lt;b&gt;&lt;a href=&#34;/blog/all&#34;&gt;Blog Index&lt;/a&gt;&lt;/b&gt;&#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;      &#xA;    &#xA;    &lt;/div&gt;&#xA;    &#xA;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;script src=&#34;/js/jquery.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/playground.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/play.js&#34;&gt;&lt;/script&gt;&#xA;&lt;script src=&#34;/js/godocs.js&#34;&gt;&lt;/script&gt;&#xA;&#xA;</content></entry></feed>';
